<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<meta name="theme-color" content="#0b0d12"/>
<link rel="manifest" href="manifest.json"/>
<title>Royal Crush — Full Gauntlet</title>
<style>
  :root{
    --bg:#0b0d12;--panel:#121521;--ink:#eaf1ff;--muted:#a7b1c6;--brand:#5bd6ff;--good:#38d39f;--bad:#ff6b6b;--warn:#ffd166;
    --accent:#7aa0ff;--accent2:#f68bf0;--card:#1a1f2d;--chip:#20263a;--border:#27304a;--glow:rgba(91,214,255,.25);
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",sans-serif}
  button{appearance:none;border:0;border-radius:12px;padding:.9rem 1rem;background:var(--chip);color:var(--ink);font-weight:700;touch-action:manipulation}
  button:disabled{opacity:.45}
  .app{max-width:760px;margin:0 auto;padding:10px 10px 90px}
  header{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:4px 2px}
  .title{font-weight:800}
  .stack{display:flex;gap:8px;flex-wrap:wrap}
  .chip{background:var(--chip);padding:6px 8px;border-radius:10px;border:1px solid var(--border);color:var(--muted);font-size:.86rem}
  .row{display:grid;gap:10px}
  .boss,.hero{background:var(--panel);border:1px solid var(--border);border-radius:16px;padding:12px}
  .boss{position:sticky;top:0;z-index:1;box-shadow:0 6px 24px rgba(0,0,0,.35)}
  .boss h2,.hero h3{margin:0 0 6px}
  .stats{display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-top:6px}
  .stat{background:var(--card);padding:8px;border-radius:12px;display:flex;align-items:center;gap:8px}
  .bar{height:10px;background:#1e2435;border-radius:8px;overflow:hidden;flex:1}
  .bar>span{display:block;height:100%;background:linear-gradient(90deg,var(--good),#42e0ff);width:100%}
  .pill{background:var(--chip);padding:4px 8px;border-radius:999px;color:var(--muted);font-weight:700;font-size:.8rem;border:1px solid var(--border)}
  .suit{font-size:1.05rem;padding:.15rem .45rem;border-radius:8px;background:#111727;border:1px solid var(--border)}
  .suit.heart{color:#ff7b7b}.suit.club{color:#7bffa1}.suit.spade{color:#7bb0ff}.suit.diamond{color:#ffd166}
  .hand{display:flex;gap:8px;flex-wrap:wrap}
  .card{background:var(--card);border:1px solid #28324b;border-radius:12px;padding:8px 10px;min-width:58px;text-align:center}
  .card .v{font-size:1.15rem;font-weight:800}
  .actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
  .actions .play{background:var(--accent);color:#061024}
  .actions .assist{background:#26304a}
  .actions .end{background:#23303a}
  .note{color:var(--muted);font-size:.9rem}
  .desc{color:var(--muted);font-size:.8rem;margin-top:4px}
  .divider{height:1px;background:#26304a;margin:10px 0}
  .log{margin-top:10px;background:#0f1320;border:1px solid #1f2740;border-radius:14px;padding:10px;max-height:240px;overflow:auto}
  .toast{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);background:#12182a;border:1px solid #27304a;padding:10px 14px;border-radius:12px;box-shadow:0 8px 28px rgba(0,0,0,.45);display:none}

  /* ===== Modal polish ===== */
  .modalWrap{position:fixed;inset:0;background:rgba(0,0,0,.55);backdrop-filter:saturate(120%) blur(2px);display:none;align-items:flex-end;z-index:9999}
  .modal{background:var(--panel);border-top-left-radius:20px;border-top-right-radius:20px;width:100%;max-width:820px;margin:0 auto;padding:14px 14px 86px;border:1px solid var(--border);border-bottom:0;box-shadow:0 -20px 60px rgba(0,0,0,.45) inset}
  .modal h4{margin:2px 0 8px}
  .modal .sub{margin:6px 0 10px}
  .choiceGrid{display:grid;grid-template-columns:1fr;gap:10px}
  @media(min-width:520px){ .choiceGrid{grid-template-columns:1fr 1fr} }
  .heroBlock{padding:8px 6px;border-radius:12px}
  .heroHead{display:flex;gap:8px;align-items:center;margin:4px 0 8px}
  .upgradeBox{background:#0e1526;border:1px solid var(--border);border-radius:14px;padding:10px;margin:6px 0 12px}
  .upgradeTitle{font-weight:800;margin-bottom:6px}
  .upLine{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .upBadge{padding:4px 8px;border-radius:999px;background:#121b31;border:1px solid var(--border);font-size:.82rem;color:var(--muted)}

  /* Reward cards */
  .rewardRow{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .rewardCard{border-radius:14px;border:1px solid var(--border);background:linear-gradient(180deg,#141a2b,#0e1424);padding:12px;box-shadow:0 8px 20px rgba(0,0,0,.25)}
  .rewardCard button{width:100%;border-radius:10px}
  .legendCard{background:linear-gradient(135deg,#ffd166 0%,#ff9bd2 50%,#80e8ff 100%);color:#0c1020;border:0;min-height:80px;display:flex;align-items:center;justify-content:center;font-size:1.02rem;font-weight:900;box-shadow:0 6px 22px var(--glow);transition:transform .06s ease}
  .legendCard:active{transform:scale(.98)}
  .genericCard{display:flex;flex-direction:column;gap:8px}
  .gName{font-weight:800}
  .chips{display:flex;gap:6px;flex-wrap:wrap}
  .chipAttr{background:#121b31;border:1px solid var(--border);color:#cbd6ff;padding:4px 8px;border-radius:999px;font-size:.78rem}
  .chosenPill{margin-top:8px}
  .stickyFooter{position:absolute;left:0;right:0;bottom:0;padding:10px 14px;background:linear-gradient(180deg,transparent,rgba(11,13,18,.75));display:flex;justify-content:flex-end}
  .btnPrimary{background:var(--accent);color:#061024;box-shadow:0 6px 18px rgba(122,160,255,.25)}
  .btnPrimary:active{transform:translateY(1px)}
  .ghost{opacity:.7}

  .dev{position:fixed;right:10px;top:10px}
  .tiny{font-size:.78rem;opacity:.85}
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="title">Royal Crush — <span class="pill">Full Gauntlet</span></div>
    <div class="stack">
      <span class="chip" id="gauntletChip">Gauntlet: —</span>
      <span class="chip" id="turnChip">Turn: —</span>
      <button class="dev tiny" id="toggleDev">Dev</button>
    </div>
  </header>

  <!-- Boss Panel -->
  <section class="boss" id="bossPanel">
    <h2>Boss: <span id="bossName">—</span> <span class="pill" id="bossRank">—</span> <span class="suit" id="bossSuit">—</span></h2>
    <div class="stats">
      <div class="stat" title="Boss HP" style="flex:1">
        <span>HP</span>
        <div class="bar"><span id="bossHpBar"></span></div>
        <strong id="bossHpTxt" style="min-width:66px;text-align:right">—</strong>
      </div>
      <div class="stat" title="Status">
        <span class="pill" id="bossPoison">☠︎ 0</span>
        <span class="pill" id="bossTarget">Targets: A</span>
      </div>
    </div>
    <div class="divider"></div>
    <div class="tiny"><span class="note">Royal ability (ability check happens before attack each Boss Phase):</span> <span id="bossAbility" class="pill">—</span></div>
  </section>

  <!-- Heroes -->
  <div class="row" id="heroesRow">
    <section class="hero" id="heroA"></section>
    <section class="hero" id="heroB"></section>
  </div>

  <div class="log" id="log"></div>
</div>

<!-- Toast -->
<div class="toast" id="toast"></div>

<!-- Rewards Modal -->
<div class="modalWrap" id="modalWrap" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
  <div class="modal" id="modal">
    <h4 id="modalTitle">Rewards</h4>
    <div class="note tiny sub" id="modalTip">Pick <strong>one</strong> reward per hero. Tap to apply; a “Chosen” chip will appear. Then Continue.</div>

    <!-- Upgrade explainer -->
    <div class="upgradeBox" id="upgradeBox">
      <div class="upgradeTitle">Upgrade this round</div>
      <div class="upLine" id="upLine"></div>
    </div>

    <!-- Choices -->
    <div class="choiceGrid" id="modalBody"></div>

    <!-- Sticky footer -->
    <div class="stickyFooter">
      <button class="btnPrimary" id="continueBtn">Continue</button>
    </div>
  </div>
</div>

<script>
/* =========================
    CONSTANTS (rules-accurate)
========================= */
const SUITS = ["♣","♥","♠","♦"];
const SUIT_NAME = { "♣":"Clubs", "♥":"Hearts", "♠":"Spades", "♦":"Diamonds" };
const RANKS = ["Jack","Queen","King","Joker"];

const RULES = {
  bossHP:   { Jack:8, Queen:14, King:18, Joker:26 },
  bossDMG:  { Jack:2, Queen:4,  King:5,  Joker:6  },
  baseDamagePerHit: 5,
  baseShield: 3,           // Knight +1
  baseHeal: 3,             // Priest +1
  basePoison: 1,           // Assassin +1
  basePlaysPerRound: 1,
  diamondCap: 2,           // Mage +1
  luckyBonus: { Mage:2, Knight:1, Assassin:1, Priest:1 },
  assistCap: 3,
};

const ELIGIBLE = {
  Knight:  new Set(["J♣","Q♣","K♣","J♥","Q♥","K♥"]),
  Mage:    new Set(["J♦","Q♦","K♦","J♠","Q♠","K♠"]),
  Assassin:new Set(["J♣","Q♣","K♣","J♠","Q♠","K♠"]),
  Priest:  new Set(["J♥","Q♥","K♥","J♦","Q♦","K♦"]),
};

/* ===== Generics with clear attributes ===== */
const GENERICS = {
  Jack: [
    {name:"Training", attrs:"+1 atk, +1 heal, Trash 1", fn:(H)=>{ addAssist(H,1); healLowest(1); }, trash:1},
    {name:"Sprint",   attrs:"+2 atk, -1 team HP, Trash 1", fn:(H)=>{ addAssist(H,2); teamLoseHP(1); }, trash:1},
    {name:"Parry",    attrs:"+Guard 2, Trash 1", fn:(H)=>{ H.shield += 2; log(`${H.name} gains Guard 2.`); }, trash:1},
  ],
  Queen: [
    {name:"Tactics",  attrs:"+2 atk, Trash 1", fn:(H)=>{ addAssist(H,2); }, trash:1},
    {name:"Rally",    attrs:"+1 atk, +1 heal, Trash 1", fn:(H)=>{ addAssist(H,1); healLowest(1); }, trash:1},
    {name:"Scout",    attrs:"+3 atk, Trash 1", fn:(H)=>{ addAssist(H,3); }, trash:1},
  ],
  King: [
    {name:"Resolve",  attrs:"+2 heal, Trash 1", fn:()=>{ healLowest(2); }, trash:1},
    {name:"Fortify",  attrs:"+1 max HP, +1 heal, Trash 1", fn:(H)=>{ H.hpMax += 1; H.hp = Math.min(H.hpMax, H.hp+1); log(`${H.name} fortifies (+1 max HP, +1 heal).`); }, trash:1},
    {name:"Purge",    attrs:"Trash 2 lowest cards", fn:(H)=>{ trashLowestCard(H); trashLowestCard(H); }, trash:0},
  ],
  Joker: [
    {name:"Chaos Spark", attrs:"+5 atk, Trash 1", fn:()=>{ applyDamage("generic", null, 5); }, trash:1},
    {name:"Chaos Trick", attrs:"+3 atk, Trash 1", fn:()=>{ applyDamage("generic", null, 3); }, trash:1},
    {name:"Chaos Ward",  attrs:"+Guard 2, Trash 1", fn:(H)=>{ H.shield += 2; log(`${H.name} gains Guard 2.`); }, trash:1},
  ],
};

/* =========================
    STATE
========================= */
const S = {
  heroes: {
    A: makeHero("A / Knight","Knight"),
    B: makeHero("B / Mage","Mage"),
  },
  boss: { rank:"Jack", suit:"♣", hp:8, hpMax:8, poison:0, target:"A", jackPlus2:false, jokerDouble:false },
  gauntlet: [],
  finisher: null,
  turn: 1,
  phase: "players",
  poisonLegendClaimed:false,
  performanceMode:false,
  timers:new Set(),
  rewards:{A:{taken:false},B:{taken:false}},
};

function makeHero(name, cls){
  const hp = (cls==="Knight"||cls==="Priest") ? 35 : 30;
  const cap = RULES.diamondCap + (cls==="Mage"?1:0);
  return {
    name, cls, hp, hpMax:hp, shield:0,
    hand:[], deck:[], discard:[],
    plays: RULES.basePlaysPerRound,
    playCap: RULES.basePlaysPerRound + cap,
    assist: 0, claimedLegend:false
  };
}

/* =========================
    INIT / GAUNTLET / DECKS
========================= */
const RNG = (()=>{ let seed = 1337; return {
  seed:(s)=>{ seed = (s||1)%2147483647; if(seed<=0) seed+=2147483646; },
  rnd:()=> (seed = seed*48271 % 2147483647)/2147483647
}})();

function init(){
  RNG.seed(1337);
  buildGauntlet();
  for (const id of ["A","B"]) {
    buildStartingDeck(id); shuffle(S.heroes[id].deck); drawUpTo(id, 4);
  }
  nextRoyal();
  paint();
  log("Run started. Good hunting.");
}

function buildGauntlet(){
  const order = [];
  for (const r of ["Jack","Queen","King"]){
    const suits = shuffle([...SUITS]);
    for (const s of suits) order.push({rank:r, suit:s});
  }
  order.push({rank:"Joker", suit:"★"},{rank:"Joker", suit:"★"});
  S.gauntlet = order;
}

function nextRoyal(){
  if (S.gauntlet.length===0){ toast("Gauntlet cleared!"); log("Victory! Both Jokers defeated."); return; }
  const r = S.gauntlet.shift();
  const hp = RULES.bossHP[r.rank];
  S.boss = { rank:r.rank, suit:r.suit, hp, hpMax:hp, poison:0, target: chooseNextTarget(), jackPlus2:false, jokerDouble:false };
  S.finisher = null;
  S.poisonLegendClaimed = false;
  S.rewards = {A:{taken:false},B:{taken:false}};
  clearTimers();

  for (const id of ["A","B"]) {
    const H = S.heroes[id];
    H.plays = RULES.basePlaysPerRound;
    H.playCap = RULES.basePlaysPerRound + (RULES.diamondCap + (H.cls==="Mage"?1:0));
    H.assist = 0;
    drawUpTo(id, 4);
  }
  S.phase = "players";
  paint();
  log(`Facing ${r.rank}${r.rank==="Joker"?"":` ${r.suit}`}.`);
}

function buildStartingDeck(id){
  const H = S.heroes[id];
  H.deck.length = 0; H.discard.length = 0; H.hand.length = 0;
  for (const v of [2,3,4,5]){
    for (const s of SUITS){
      H.deck.push({v, s});
    }
  }
}

function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(RNG.rnd()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

/* =========================
    CORE HELPERS
========================= */
function rollD12(){ return 1+Math.floor(RNG.rnd()*12); }
function toast(t){ const el=document.getElementById('toast'); el.textContent=t; el.style.display='block'; clearTimeout(el._t); el._t=setTimeout(()=>el.style.display='none',1400); }
function log(t){ const el=document.getElementById('log'); const line=document.createElement('div'); line.textContent=`• ${t}`; el.prepend(line); if(!S.performanceMode){ el.scrollTop=0; } }
function royalKey(rank, suit){ if(rank==="Joker") return "Joker"; return `${rank[0]}${suit}`; }
function livingHeroIds(){ return ["A","B"].filter(id=>S.heroes[id].hp>0); }
function lowestLivingHeroId(){
  const live = livingHeroIds();
  if (live.length===0) return null;
  if (live.length===1) return live[0];
  const [id1,id2]=live;
  return S.heroes[id1].hp <= S.heroes[id2].hp ? id1 : id2;
}
function chooseNextTarget(){
  const nextDefault = (S.boss?.target==="A") ? "B" : "A";
  const live = livingHeroIds();
  if (live.includes(nextDefault)) return nextDefault;
  return live[0] ?? "A";
}
function schedule(fn, ms){
  const id = setTimeout(()=>{ S.timers.delete(id); fn(); }, ms);
  S.timers.add(id);
}
function clearTimers(){
  for (const id of Array.from(S.timers)){ clearTimeout(id); }
  S.timers.clear();
}

/* =========================
    PLAYER ACTIONS
========================= */
function playCard(heroId, value, suit){
  const H = S.heroes[heroId];
  if (S.phase!=="players"){ toast("Wait for your turn."); return; }
  if (H.plays<=0){ toast("No plays left."); return; }

  const idx = H.hand.findIndex(c=>c.v===value && c.s===suit);
  if (idx<0){ toast("Card not in hand."); return; }
  const card = H.hand.splice(idx,1)[0];
  H.plays -= 1;

  const d12 = rollD12();
  const mod = H.assist || 0;
  H.assist = 0;
  const total = d12 + mod;
  const hit = total <= card.v;
  const fumble = (d12===12);
  const lucky = (d12===1);
  const luckyBonus = RULES.luckyBonus[H.cls] || 0;

  let suitShield = 0, suitHeal = 0, suitPoison = 0, suitExtraPlay = 0;
  if (hit){
    if (card.s==="♣"){ suitShield = RULES.baseShield + (H.cls==="Knight"?1:0); }
    if (card.s==="♥"){ suitHeal   = RULES.baseHeal   + (H.cls==="Priest"?1:0); }
    if (card.s==="♠"){ suitPoison = RULES.basePoison + (H.cls==="Assassin"?1:0); }
    if (card.s==="♦"){ suitExtraPlay = 1; }
  }
  if (fumble){
    suitShield = Math.floor(suitShield/2);
    suitHeal   = Math.floor(suitHeal/2);
    suitPoison = Math.floor(suitPoison/2);
    suitExtraPlay = Math.floor(suitExtraPlay/2);
  }

  if (suitShield>0){ H.shield += suitShield; log(`${H.name} gains Shield ${suitShield} from ${card.v}♣.`); }
  if (suitHeal>0){ const id = lowestLivingHeroId(); if(id){ const T=S.heroes[id]; const before=T.hp; T.hp=Math.min(T.hpMax, T.hp + suitHeal); log(`${H.name} heals ${T.name} for ${T.hp-before} from ${card.v}♥.`);} }
  if (suitPoison>0){ S.boss.poison += suitPoison; log(`${H.name} adds ${suitPoison} poison from ${card.v}♠.`); }
  if (suitExtraPlay>0){
    const cap = H.playCap;
    if (H.plays < cap){ H.plays = Math.min(cap, H.plays + 1); log(`${H.name} gains +1 play (cap ${cap}).`); }
    else { log(`${H.name} is at play cap (${cap}). ♦ provides no extra play.`); }
  }

  let extraDmg = 0;
  if (lucky){ extraDmg += luckyBonus; log(`${H.name} rolled a natural 1 → Lucky +${luckyBonus} dmg.`); }

  if (hit){
    const dmg = RULES.baseDamagePerHit + extraDmg;
    applyDamage("hit", heroId, dmg);
    log(`${H.name} hits (d12 ${d12}${mod?`+${mod}`:""} ≤ ${card.v}) for ${dmg}.`);
  } else {
    log(`${H.name} misses (d12 ${d12}${mod?`+${mod}`:""} > ${card.v}).`);
  }

  if (fumble){
    const id = lowestLivingHeroId();
    if(id){ const T=S.heroes[id]; T.hp = Math.max(0, T.hp - 1); log(`FUMBLE! ${T.name} takes 1 damage.`); }
  }

  if (S.heroes.A.plays<=0 && S.heroes.B.plays<=0){
    S.phase = "boss";
    schedule(bossPhase, 250);
  }

  paint();
}

function assist(fromId){
  const toId = fromId==="A" ? "B" : "A";
  const F = S.heroes[fromId], T = S.heroes[toId];
  if (S.phase!=="players"){ toast("Wait for your turn."); return; }
  if (F.plays<=0){ toast("No plays left."); return; }
  if (F.hand.length===0){ toast("No cards to sacrifice."); return; }

  const give = Math.min(F.hand.length, RULES.assistCap - (T.assist||0));
  if (give<=0){ toast("Partner is at assist cap."); return; }
  const removed = F.hand.splice(0, give);
  F.discard.push(...removed);
  F.plays -= 1;
  T.assist = Math.min((T.assist||0) + give, RULES.assistCap);
  log(`${F.name} assists ${T.name}: +${give} to next roll (cap ${RULES.assistCap}).`);
  paint();
}

function endTurn(heroId){
  if (S.phase!=="players") return;
  S.heroes[heroId].plays = 0;
  if (S.heroes.A.plays<=0 && S.heroes.B.plays<=0){
    S.phase = "boss";
    schedule(bossPhase, 220);
  }
  paint();
}

/* =========================
    DAMAGE & KILL
========================= */
function applyDamage(via, who, dmg){
  const key = royalKey(S.boss.rank, S.boss.suit);
  S.finisher = { via, who, royal:key };
  S.boss.hp = Math.max(0, S.boss.hp - dmg);
  if (S.boss.hp===0){ onBossDefeated(); }
  paint();
}

function onBossDefeated(){
  clearTimers();
  S.phase = "rewards";
  log(`Defeated ${S.boss.rank}${S.boss.rank==="Joker"?"":" " + S.boss.suit}!`);

  const upByRank = { Jack:6, Queen:7, King:8, Joker:9 };
  const upVal = upByRank[S.boss.rank];
  for (const id of ["A","B"]){
    const H = S.heroes[id];
    const s = (S.boss.rank==="Joker") ? SUITS[Math.floor(RNG.rnd()*4)] : S.boss.suit;
    H.discard.push({v:upVal, s});
  }
  log(`Both heroes gain a ${upVal}${S.boss.rank==="Joker"?" (random suit)":" of "+S.boss.suit} to discard.`);

  S.rewards = {A:{taken:false},B:{taken:false}};
  simpleLegendaryGrant();
  openRewardsModal();
}

function simpleLegendaryGrant(){
  if (!S.finisher || S.boss.rank==="Joker" || S.finisher.via!=="hit") return;
  const heroId = S.finisher.who;
  const H = S.heroes[heroId];
  const set = ELIGIBLE[H.cls];
  if (set && set.has(S.finisher.royal)){
    H.claimedLegend = true;
    S.rewards[heroId].taken = true;
    log(`${H.name} auto-claims Legendary (${S.finisher.royal}).`);
    toast(`${H.name} auto-claims a Legendary!`);
  }
}

/* =========================
    BOSS PHASE
========================= */
function bossPhase(){
  if (S.phase==="rewards") return;
  if (livingHeroIds().length===0){ log("Both heroes are down. Run ends."); toast("Defeat"); return; }

  if (S.boss.poison>0){
    const tick = S.boss.poison;
    S.boss.hp = Math.max(0, S.boss.hp - tick);
    log(`Poison ticks for ${tick}.`);
    if (S.boss.hp===0){
      S.finisher = { via:"poison", who:null, royal: royalKey(S.boss.rank, S.boss.suit) };
      onBossDefeated(); paint(); return;
    }
  }

  const d12 = rollD12();
  switch (S.boss.rank){
    case "Jack": if (d12>=1 && d12<=3){ S.boss.jackPlus2 = true; log("Jack ability triggers: +2 to next attack."); } break;
    case "Queen": if (d12>=1 && d12<=3){ S.boss.hp = Math.min(S.boss.hpMax, S.boss.hp + 3); log("Queen ability triggers: heal 3."); } break;
    case "King": if (d12>=1 && d12<=2){ if (S.boss.poison>0){ S.boss.poison = 0; log("King ability triggers: purges all poison."); } } break;
    case "Joker": if (d12>=8 && d12<=10){ S.boss.jokerDouble = true; log("Joker ability: next attack will deal double damage."); } break;
  }

  let target = S.boss.target;
  if (S.heroes[target].hp<=0){
    const live = livingHeroIds();
    target = live[0] ?? target;
  }
  if (livingHeroIds().length===0){ log("Both heroes are down. Run ends."); toast("Defeat"); return; }

  const base = RULES.bossDMG[S.boss.rank];
  let dmg = base;
  if (S.boss.jackPlus2){ dmg += 2; S.boss.jackPlus2=false; }
  if (S.boss.jokerDouble){ dmg *= 2; S.boss.jokerDouble=false; }

  const H = S.heroes[target];
  const soaked = Math.min(H.shield, dmg);
  const taken = Math.max(0, dmg - soaked);
  H.shield = Math.max(0, H.shield - dmg);
  H.hp = Math.max(0, H.hp - taken);
  log(`Boss attacks ${H.name} for ${dmg}. Shield soaked ${soaked}, took ${taken}.`);

  S.boss.target = (target==="A") ? "B" : "A";

  for (const id of ["A","B"]){
    const hero = S.heroes[id];
    if (hero.hp>0){
      hero.plays = RULES.basePlaysPerRound;
      hero.playCap = RULES.basePlaysPerRound + (RULES.diamondCap + (hero.cls==="Mage"?1:0));
      drawUpTo(id, 4);
    } else { hero.plays = 0; }
    hero.assist = 0;
  }

  S.turn += 1;
  S.phase = "players";
  paint();
}

/* =========================
    UPGRADE PREVIEW
========================= */
function suitEffectSummary(s){
  if (s==="♣") return "Guard: gain Shield +3 (Knight +1).";
  if (s==="♥") return "Heal: heal lowest +3 (Priest +1).";
  if (s==="♠") return "Poison: add +1 poison (Assassin +1).";
  if (s==="♦") return "Play: +1 play (to 1+Diamond Cap; Mage +1 cap).";
  return "";
}
function upgradePreview(rank, suit){
  const upByRank = { Jack:6, Queen:7, King:8, Joker:9 };
  const v = upByRank[rank];
  const line = document.getElementById('upLine');
  line.innerHTML = "";
  if (rank==="Joker"){
    const t = document.createElement('div');
    t.className = 'note';
    t.innerHTML = `Each hero gains <strong>${v}</strong> of a <em>random suit</em>.`;
    const suits = [
      ["♣","Guard +3 (Knight +1)"],
      ["♥","Heal +3 (Priest +1)"],
      ["♠","Poison +1 (Assassin +1)"],
      ["♦","+1 Play (to cap; Mage +1 cap)"],
    ];
    line.appendChild(t);
    suits.forEach(([sym,txt])=>{
      const b=document.createElement('div'); b.className='upBadge';
      b.textContent = `${sym} ${txt}`;
      line.appendChild(b);
    });
  } else {
    const b1=document.createElement('div'); b1.className='upBadge'; b1.textContent=`+${v} ${suit}`;
    const b2=document.createElement('div'); b2.className='upBadge'; b2.textContent=suitEffectSummary(suit);
    line.appendChild(b1); line.appendChild(b2);
  }
}

/* =========================
    REWARDS MODAL (beautified)
========================= */
function parseAttrChips(text){
  // very lightweight parser -> chips with icons
  const parts = text.split(',').map(s=>s.trim().toLowerCase());
  const chips=[];
  parts.forEach(p=>{
    if (p.includes('atk')) chips.push(`⚔ ${p.replace('atk','atk')}`);
    else if (p.includes('heal')) chips.push(`✚ ${p}`);
    else if (p.includes('guard')) chips.push(`🛡 ${p}`);
    else if (p.includes('poison')) chips.push(`☠ ${p}`);
    else if (p.includes('play')) chips.push(`▶ ${p}`);
    else if (p.includes('team hp')) chips.push(`❤️ ${p}`);
    else if (p.includes('trash')) chips.push(`🗑 ${p}`);
    else chips.push(p);
  });
  return chips;
}

function openRewardsModal(){
  const wrap = document.getElementById('modalWrap');
  const body = document.getElementById('modalBody');
  body.innerHTML = "";

  // Upgrade explanation card
  upgradePreview(S.boss.rank, S.boss.suit);

  // Build a block per hero
  ["A","B"].forEach(id=>{
    const H = S.heroes[id];

    const heroBlock = document.createElement('div');
    heroBlock.className = "heroBlock rewardCard";

    const head = document.createElement('div');
    head.className = "heroHead";
    head.innerHTML = `<strong style="font-size:1.05rem">${H.name}</strong> <span class="pill">${H.cls}</span> <span class="pill">HP ${H.hp}/${H.hpMax}</span>`;
    heroBlock.appendChild(head);

    const row = document.createElement('div');
    row.className = "rewardRow";

    // If already taken, just show the chosen pill
    if (S.rewards[id]?.taken){
      const takenNote = document.createElement('div');
      takenNote.className = "note";
      takenNote.textContent = H.claimedLegend ? "Legendary granted. (Chosen)" : "Reward claimed. (Chosen)";
      heroBlock.appendChild(takenNote);
    } else {
      const isJoker = S.boss.rank==="Joker";
      // Poison-claim (not for Joker)
      if (!isJoker && S.finisher?.via==="poison" && !S.poisonLegendClaimed){
        const legendCard = document.createElement('button');
        legendCard.className = "legendCard";
        legendCard.textContent = "Claim Legendary";
        legendCard.onclick = ()=>{
          S.poisonLegendClaimed = true;
          H.claimedLegend = true;
          S.rewards[id] = { taken:true, chosen:"Legendary" };
          toast(`${H.name} claimed a Legendary.`);
          openRewardsModal();
        };
        const container = document.createElement('div'); container.className="rewardCard";
        container.appendChild(legendCard);
        row.appendChild(container);
      }

      // Generics
      const hitAuto = H.claimedLegend===true && S.finisher?.via==="hit";
      if (!hitAuto && !(S.finisher?.via==="poison" && S.poisonLegendClaimed)){
        (GENERICS[S.boss.rank]||[]).forEach(opt=>{
          const card = document.createElement('div'); card.className="rewardCard genericCard";
          const name = document.createElement('div'); name.className="gName"; name.textContent = opt.name;
          const chips = document.createElement('div'); chips.className="chips";
          parseAttrChips(opt.attrs).forEach(t=>{
            const ch=document.createElement('div'); ch.className='chipAttr'; ch.textContent=t; chips.appendChild(ch);
          });
          const btn = document.createElement('button'); btn.textContent="Choose";
          btn.onclick = ()=>{
            opt.fn(H);
            if (opt.trash>0){ trashLowestCard(H); if (opt.trash===2) trashLowestCard(H); }
            S.rewards[id] = { taken:true, chosen: opt.name };
            toast(`${H.name} chose ${opt.name}`);
            openRewardsModal();
          };
          card.appendChild(name); card.appendChild(chips); card.appendChild(btn);
          row.appendChild(card);
        });
      }

      if (S.boss.rank==="Joker"){
        const n = document.createElement('div'); n.className="note ghost"; n.style.gridColumn="1/-1";
        n.textContent = "Joker defeated: no Legendary offered.";
        row.appendChild(n);
      }
    }

    // If chosen, show pill
    if (S.rewards[id]?.chosen){
      const chosen = document.createElement('div'); chosen.className='pill chosenPill';
      chosen.textContent = `✓ Chosen: ${S.rewards[id].chosen}`;
      heroBlock.appendChild(chosen);
    }

    heroBlock.appendChild(row);
    body.appendChild(heroBlock);
  });

  // Continue button
  const cont = document.getElementById('continueBtn');
  cont.onclick = ()=>{ closeRewardsModal(); nextRoyal(); };

  wrap.style.display = "flex";
  S.phase = "rewards";
}

function closeRewardsModal(){ document.getElementById('modalWrap').style.display='none'; }

/* =========================
    CARDS / DECK / DRAW / TRASH
========================= */
function drawUpTo(id, n){
  const H = S.heroes[id];
  while (H.hp>0 && H.hand.length < n){
    if (H.deck.length===0){
      if (H.discard.length===0) break;
      H.deck.push(...H.discard);
      H.discard.length = 0;
      shuffle(H.deck);
    }
    const c = H.deck.shift();
    H.hand.push(c);
  }
}

function trashLowestCard(H){
  const getMinIndex = (arr)=> {
    if (!arr.length) return -1;
    let mV = arr[0].v, mI = 0;
    for (let i=1;i<arr.length;i++){ if (arr[i].v < mV){ mV = arr[i].v; mI = i; } }
    return mI;
  };
  let i = getMinIndex(H.deck);
  if (i>=0){ const c=H.deck.splice(i,1)[0]; log(`${H.name} trashes ${c.v}${c.s} (deck).`); return; }
  i = getMinIndex(H.discard);
  if (i>=0){ const c=H.discard.splice(i,1)[0]; log(`${H.name} trashes ${c.v}${c.s} (discard).`); return; }
  i = getMinIndex(H.hand);
  if (i>=0){ const c=H.hand.splice(i,1)[0]; log(`${H.name} trashes ${c.v}${c.s} (hand).`); return; }
}

/* small helpers for generic effects */
function addAssist(H, n){ H.assist = Math.min((H.assist||0)+n, RULES.assistCap); }
function healLowest(n){
  const id = lowestLivingHeroId(); if(!id) return;
  const T = S.heroes[id]; const before=T.hp;
  T.hp = Math.min(T.hpMax, T.hp + n);
  log(`${T.name} heals ${T.hp - before}.`);
}
function teamLoseHP(n){
  for (const id of ["A","B"]){
    const H = S.heroes[id]; if (H.hp>0){ H.hp = Math.max(0, H.hp - n); }
  }
}

/* =========================
    UI RENDER
========================= */
function paint(){
  const nm = `${S.boss.rank}${S.boss.rank==="Joker"?"":" of "+SUIT_NAME[S.boss.suit]}`;
  document.getElementById('bossName').textContent = nm;
  document.getElementById('bossRank').textContent = S.boss.rank[0];
  const bs = document.getElementById('bossSuit');
  bs.textContent = S.boss.rank==="Joker" ? "★" : S.boss.suit;
  bs.className = "suit " + (S.boss.rank==="Joker" ? "" :
    (S.boss.suit==="♥"?"heart":S.boss.suit==="♣"?"club":S.boss.suit==="♠"?"spade":"diamond"));

  const hpPct = (S.boss.hp/S.boss.hpMax)*100;
  document.getElementById('bossHpBar').style.width = Math.max(0,hpPct)+"%";
  document.getElementById('bossHpTxt').textContent = `${S.boss.hp}/${S.boss.hpMax}`;
  document.getElementById('bossPoison').textContent = `☠︎ ${S.boss.poison}`;
  document.getElementById('bossTarget').textContent = `Targets: ${S.boss.target}`;
  document.getElementById('bossAbility').textContent =
    (S.boss.rank==="Jack")  ? "On d12 1–3: +2 to next attack." :
    (S.boss.rank==="Queen") ? "On d12 1–3: Heal 3." :
    (S.boss.rank==="King")  ? "On d12 1–2: Purge all poison." :
                               "On d12 8–10: Next attack deals double.";

  document.getElementById('gauntletChip').textContent = `Gauntlet left: ${S.gauntlet.length+1}`;
  document.getElementById('turnChip').textContent = `Turn ${S.turn} • ${S.phase}`;

  renderHero("A");
  renderHero("B");
}

function renderHero(id){
  const H = S.heroes[id];
  const wrap = document.getElementById(id==="A"?"heroA":"heroB");
  wrap.innerHTML = `
    <h3>${H.name} <span class="pill">${H.cls}</span></h3>
    <div class="stats">
      <div class="stat" style="flex:1">
        <span>HP</span>
        <div class="bar"><span style="width:${(H.hp/H.hpMax)*100}%"></span></div>
        <strong style="min-width:66px;text-align:right">${H.hp}/${H.hpMax}</strong>
      </div>
      <div class="stat"><span>Shield</span><strong>${H.shield}</strong></div>
      <div class="stat"><span>Plays</span><strong>${H.plays}/${H.playCap}</strong></div>
      <div class="stat"><span>Assist</span><strong>+${H.assist||0}</strong></div>
    </div>
    <div class="divider"></div>
    <div class="note tiny">Hand</div>
    <div class="hand">
      ${H.hand.map((c)=>(
        `<div class="card" aria-label="${c.v} of ${SUIT_NAME[c.s]}">
           <div class="v">${c.v}<span class="suit ${c.s==='♥'?'heart':c.s==='♣'?'club':c.s==='♠'?'spade':'diamond'}"> ${c.s}</span></div>
           <div class="actions">
             <button class="play" ${H.hp<=0?'disabled':''} onclick="playCard('${id}', ${c.v}, '${c.s}')">Play</button>
           </div>
         </div>`
      )).join('')}
    </div>
    <div class="actions">
      <button class="assist" ${H.hp<=0?'disabled':''} onclick="assist('${id}')">Assist partner (-1 play)</button>
      <button class="end" ${H.hp<=0?'disabled':''} onclick="endTurn('${id}')">End turn</button>
    </div>
  `;
}

/* =========================
    DEV DRAWER
========================= */
let devOpen=false;
document.getElementById('toggleDev').addEventListener('click',()=>{ devOpen=!devOpen; if (devOpen) openDev(); else closeDev(); });
function openDev(){
  const wrap=document.createElement('div');
  wrap.id="devDrawer";
  wrap.style.position="fixed"; wrap.style.right="10px"; wrap.style.top="50px";
  wrap.style.background="#0f1424"; wrap.style.border="1px solid #27304a"; wrap.style.borderRadius="12px";
  wrap.style.padding="10px"; wrap.style.width="280px"; wrap.style.zIndex="5";
  wrap.innerHTML = `
    <div style="font-weight:800;margin-bottom:6px">Dev</div>
    <div class="tiny">Performance Mode reduces log scrolling.</div>
    <div class="divider"></div>
    <button onclick="S.performanceMode=!S.performanceMode; toast('Performance mode: '+S.performanceMode)">Toggle Perf</button>
    <button style="margin-left:6px" onclick="S.boss.hp=1; paint();">Set Boss 1 HP</button>
    <div class="divider"></div>
    <button onclick="forcePoisonKill()">Force Poison Kill</button>
    <button style="margin-left:6px" onclick="nextRoyal();">Skip to Next Royal</button>
  `;
  document.body.appendChild(wrap);
}
function closeDev(){ const d=document.getElementById('devDrawer'); if(d) d.remove(); }
function forcePoisonKill(){ S.boss.poison = Math.max(1, S.boss.hp); bossPhase(); }

/* =========================
    EVENTS / BOOT
========================= */
document.getElementById('modalWrap').addEventListener('click',(e)=>{ if(e.target.id==="modalWrap") closeRewardsModal(); });
document.getElementById('continueBtn').addEventListener('click',()=>{ closeRewardsModal(); nextRoyal(); });
init();
</script>
</body>
</html>
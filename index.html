<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Royal Crush — Full Gauntlet</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#0f1115">
<style>
  :root{
    --bg:#0f1115; --panel:#171a21; --ink:#e9eef6; --sub:#aab3c2;
    --line:#272c3b; --chip:#141a24; --chipline:#293143;
    --accent:#60a5fa; --good:#34d399; --warn:#f59e0b; --bad:#ef4444;
    --overlay:rgba(0,0,0,.55)
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font:15px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
  .wrap{max-width:980px;margin:0 auto;padding:14px}
  h1{margin:0 0 12px;font-size:22px}
  .card{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:14px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .between{display:flex;justify-content:space-between;align-items:center}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  @media (max-width:720px){ .grid2{grid-template-columns:1fr} }

  .btn{padding:10px 12px;border-radius:12px;border:1px solid var(--line);background:#151924;color:var(--ink);cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .btn.gray{background:#141922;border-color:#252c3c}
  .btn.green{background:#13301f;border-color:#1b3e29}
  .btn.red{background:#2a1215;border-color:#3a1e23}
  .mini{padding:2px 8px;font-size:11px}

  .chip{background:var(--chip);border:1px solid var(--chipline);border-radius:999px;padding:4px 8px;font-size:12px;color:#e8f1ff}
  .sub{color:var(--sub);font-size:12px}
  .statline{display:flex;gap:8px;flex-wrap:wrap;color:#cfe3ff;font-size:12px;opacity:.9}

  .bar{height:14px;background:#0e1420;border:1px solid #283045;border-radius:999px;overflow:hidden}
  .bar>span{display:block;height:100%;background:linear-gradient(90deg,var(--accent),var(--good));transition:width .18s ease}

  .hand{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
  .cardlet{
    min-width:42px;padding:8px;border-radius:8px;border:1px solid #2b3244;background:#121722;
    cursor:pointer;text-align:center;font-weight:700
  }
  .cardlet.sel{outline:2px solid var(--accent); outline-offset:2px}
  .hide{display:none}

  .toasts{position:fixed; top:12px; right:12px; display:flex; flex-direction:column; gap:8px; z-index:9999}
  .toast{background:#121722;border:1px solid #2b3142;border-radius:10px;padding:10px 12px; box-shadow:0 8px 24px rgba(0,0,0,.35)}
  .toast.bad{border-color:#5a1d21;background:#281215}
  .toast.good{border-color:#1f3e29;background:#132018}

  .overlay{position:fixed; inset:0; background:var(--overlay); display:none; align-items:center; justify-content:center; z-index:9998}
  .overlay.show{display:flex}
  .modal{width:min(920px,94vw); max-height:86vh; overflow:auto; background:#151922; border:1px solid #2a3040; border-radius:14px; box-shadow:0 18px 48px rgba(0,0,0,.5); padding:14px}
  .modal h3{margin:0 0 8px; font-size:16px}
  .list{border:1px solid #2a3142; border-radius:10px; padding:10px}
  .tag{
    display:inline-block; border:1px solid #3a69c9; border-radius:8px;
    padding:6px 8px; margin:4px; font-size:13px; background:#0b1b3a; color:#eaf2ff;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.06)
  }
  .log{margin-top:8px; font-size:12px; color:#cfe3ff; opacity:.95}
  .log .line{padding:4px 0; border-bottom:1px dashed #2a3142}
  .pill{border-radius:999px; padding:2px 8px; font-size:11px; border:1px solid #2b3244; background:#111825; color:#d9e6ff}
  .suits{font-weight:700; opacity:.9}
</style>
</head>
<body>
<div class="wrap">
  <h1>Royal Crush — Full Gauntlet</h1>
  <div class="toasts" id="toasts"></div>

  <!-- BOSS PANEL -->
  <div class="card" id="bossPanel">
    <div class="between">
      <div>
        <div class="sub">Royal</div>
        <div style="font-size:20px;font-weight:700" id="bossName">—</div>
        <div class="sub" id="bossStats">HP — • DMG —</div>
      </div>
      <div style="text-align:right">
        <div class="chip">Round <span id="roundOut">1</span></div>
        <div class="chip">POI <span id="poiVal">0</span></div>
      </div>
    </div>

    <div class="row" style="align-items:center; gap:12px; margin-top:8px">
      <div style="flex:1">
        <div class="bar"><span id="hpBar" style="width:0%"></span></div>
        <div class="between" style="margin-top:6px">
          <div style="font-size:18px;font-weight:700"><span id="hpNow">0</span>/<span id="hpMax">0</span></div>
          <div class="sub" id="prog">Run: —</div>
        </div>
      </div>
      <div class="row">
        <button class="btn mini" id="poiPlus">+POI</button>
        <button class="btn mini" id="poiMinus">−POI</button>
      </div>
    </div>

    <div class="log" id="bossLog"></div>
  </div>

  <!-- HEROES -->
  <div class="grid2" style="margin-top:12px">
    <!-- A -->
    <div class="card" id="heroA">
      <div class="between">
        <div class="row" style="gap:8px;align-items:center">
          <select id="classA"><option>Knight</option><option>Mage</option><option>Assassin</option><option>Priest</option></select>
          <span class="suits" id="suitsA"></span>
          <div class="chip">HP <span id="hpA">35</span></div>
          <span class="pill" id="assistChipA" style="display:none">Assist +0</span>
        </div>
        <div class="row" style="gap:6px">
          <button class="btn mini gray" id="hpAMinus">−1</button>
          <button class="btn mini gray" id="hpAPlus">+1</button>
        </div>
      </div>
      <div class="statline" style="margin-top:6px">
        <div>Plays: <span id="playsA">1</span></div>
        <div>Deck: <span id="deckCountA">0</span></div>
        <div>Discard: <span id="discCountA">0</span></div>
        <div>Hand: <span id="handCountA">0</span></div>
      </div>
      <div class="hand" id="handA"></div>
      <div class="row" style="margin-top:6px">
        <button class="btn" id="rollA" style="flex:1">Play Selected & Roll d12</button>
        <button class="btn gray" id="assistA">Assist Partner</button>
        <div class="chip" id="rollOutA">—</div>
        <div class="chip" id="resultA">—</div>
      </div>
    </div>
    <!-- B -->
    <div class="card" id="heroB">
      <div class="between">
        <div class="row" style="gap:8px;align-items:center">
          <select id="classB"><option>Knight</option><option selected>Mage</option><option>Assassin</option><option>Priest</option></select>
          <span class="suits" id="suitsB"></span>
          <div class="chip">HP <span id="hpB">30</span></div>
          <span class="pill" id="assistChipB" style="display:none">Assist +0</span>
        </div>
        <div class="row" style="gap:6px">
          <button class="btn mini gray" id="hpBMinus">−1</button>
          <button class="btn mini gray" id="hpBPlus">+1</button>
        </div>
      </div>
      <div class="statline" style="margin-top:6px">
        <div>Plays: <span id="playsB">1</span></div>
        <div>Deck: <span id="deckCountB">0</span></div>
        <div>Discard: <span id="discCountB">0</span></div>
        <div>Hand: <span id="handCountB">0</span></div>
      </div>
      <div class="hand" id="handB"></div>
      <div class="row" style="margin-top:6px">
        <button class="btn" id="rollB" style="flex:1">Play Selected & Roll d12</button>
        <button class="btn gray" id="assistB">Assist Partner</button>
        <div class="chip" id="rollOutB">—</div>
        <div class="chip" id="resultB">—</div>
      </div>
    </div>
  </div>

  <div class="row" style="margin-top:12px">
    <button class="btn gray" id="newRunBtn">New Run (gauntlet only)</button>
    <button class="btn gray" id="resetBoss">New Game</button>
    <label class="row" style="gap:6px;margin-left:auto">
      <input type="checkbox" id="perfModeChk" />
      <span class="sub">Performance Mode</span>
    </label>
  </div>
</div>

<!-- Rewards Modal -->
<div class="overlay" id="rewardsOverlay">
  <div class="modal">
    <div class="between" style="margin-bottom:8px">
      <h3>Royal Defeated — Rewards</h3>
      <button class="btn" id="closeRewards">Close</button>
    </div>
    <div class="sub" id="rewHint">
      Each hero auto-adds: J→6, Q→7, K→8, Joker→9 (to discard).<br/>
      <b>Legendary:</b> Killing blow with <b>matching suit</b> auto-grants to that hero. If <b>poison</b> killed, either hero may claim (one total). Jokers grant no Legendary.
    </div>
    <div class="grid2" style="margin-top:10px">
      <div class="list">
        <div class="sub" style="margin-bottom:6px">Hero A choices</div>
        <div id="choicesA"></div>
      </div>
      <div class="list">
        <div class="sub" style="margin-bottom:6px">Hero B choices</div>
        <div id="choicesB"></div>
      </div>
    </div>
    <div class="row" style="margin-top:10px">
      <button class="btn green" id="ackRewards">Next Royal</button>
      <div class="sub">Upgrades/Legendaries go to discard; appear after reshuffle.</div>
    </div>
  </div>
</div>

<!-- Assist Modal -->
<div class="overlay" id="assistOverlay">
  <div class="modal">
    <div class="between" style="margin-bottom:8px">
      <h3>Assist Partner — Sacrifice Cards</h3>
      <button class="btn" id="assistClose">Close</button>
    </div>
    <div class="sub">Select any number of cards to discard. Partner gains +1 to next d12 per card (max +3). Costs 1 play.</div>
    <div class="list" style="margin-top:10px">
      <div class="hand" id="assistPickZone"></div>
    </div>
    <div class="row" style="margin-top:10px">
      <button class="btn green" id="assistConfirm">Confirm Assist</button>
      <div class="chip" id="assistSummary">0 selected → +0 to partner</div>
    </div>
  </div>
</div>

<script>
/* ====== Config & Data ====== */
const CFG={DMG:5, BASE_PLAYS:1, CAP_DIAMOND:2, SHIELD:3, HEAL:3, POI:1, ASSIST_CAP:3};
const SUITS=['♣','♠','♥','♦'];
const bossDefs={J:{name:'Jacks',hp:8,atk:2},Q:{name:'Queens',hp:14,atk:4},K:{name:'Kings',hp:18,atk:5},X:{name:'Jokers',hp:26,atk:6}};
const classMods={
  Knight:{maxHP:35,diamondCap:0,lucky:0,shield:1,heal:0,poi:0,suits:['♣','♥']},
  Mage:{  maxHP:30,diamondCap:1,lucky:1,shield:0,heal:0,poi:0,suits:['♦','♠']},
  Assassin:{maxHP:30,diamondCap:0,lucky:0,shield:0,heal:0,poi:1,suits:['♣','♠']},
  Priest:{maxHP:35,diamondCap:0,lucky:0,heal:1,shield:0,poi:0,suits:['♥','♦']},
};
/* Legendaries & Generics */
const legendaryEffects={
  Knight:{'J♣':h=>deal(6),'Q♣':h=>addPlay(h),'K♣':h=>deal(Math.ceil(currBoss().max/3)+4),'J♥':h=>teamHeal(4),'Q♥':h=>teamHeal(3),'K♥':h=>shield(3,h)},
  Mage:{'J♦':h=>{deal(3);teamHeal(1);},'Q♦':h=>deal(4),'K♦':h=>{deal(8);addPoison(4);},'J♠':h=>addPoison(3),'Q♠':h=>shield(3,h),'K♠':h=>{deal(2);addPoison(2);}},
  Assassin:{'J♣':h=>{deal(2);addPoison(1);},'Q♣':h=>{deal(2);addPoison(1);},'K♣':h=>deal(9),'J♠':h=>addPoison(1),'Q♠':h=>shield(3,h),'K♠':h=>addPoison(1)},
  Priest:{'J♥':h=>{teamHeal(2);deal(3);},'Q♥':h=>{teamHeal(3);deal(3);},'K♥':h=>{const low=lowestHero(); low.hp=Math.max(low.hp,Math.ceil(low.maxHP/2)); low.down=false;},'J♦':h=>deal(2),'Q♦':h=>{deal(1);teamHeal(1);},'K♦':h=>{deal(5);addPoison(2);teamHeal(2);}},
};
const GENERICS_ALL={
  training:{label:'Training · +1⚔ +1♥',run:h=>{deal(1);teamHeal(1)}},
  sprint:{label:'Sprint · +2⚔, team −1',run:h=>{deal(2);teamHurt(1)}},
  parry:{label:'Parry · Guard +2',run:h=>{shield(2,h)}},
  tactics:{label:'Tactics · +2⚔',run:h=>{deal(2)}},
  rally:{label:'Rally · +1⚔ +1♥',run:h=>{deal(1);teamHeal(1)}},
  scout:{label:'Scout · +3⚔',run:h=>{deal(3)}},
  resolve:{label:'Resolve · +2♥',run:h=>{teamHeal(2)}},
  fortify:{label:'Fortify · +1 Max♥ +1♥',run:h=>{const t=lowestHero(); t.maxHP+=1; t.hp=Math.min(t.maxHP,t.hp+1)}},
  purge:{label:'Purge · Trash 2 lowest',run:h=>{autoTrashLowest(h,2)}},
  spark:{label:'Chaos Spark · +5⚔',run:h=>{deal(5)}},
  trick:{label:'Chaos Trick · +3⚔',run:h=>{deal(3)}},
  ward:{label:'Chaos Ward · Guard +2',run:h=>{shield(2,h)}},
};
const GENERIC_BY_RANK={J:['training','sprint','parry'],Q:['tactics','rally','scout'],K:['resolve','fortify','purge'],X:['spark','trick','ward']};

/* ====== State ====== */
const $=id=>document.getElementById(id);
const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
const d12=()=>Math.floor(Math.random()*12)+1;
const shuffle=a=>{for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a};
function startDeck(){ const d=[]; [2,3,4,5].forEach(v=>SUITS.forEach(s=>d.push({type:'num',v,s}))); return shuffle(d); }
function makeHero(cls){ const m=classMods[cls]; return {cls,hp:m.maxHP,maxHP:m.maxHP,plays:CFG.BASE_PLAYS,playsMax:CFG.BASE_PLAYS,diamond:0,shield:0,down:false,deck:startDeck(),discard:[],hand:[],nextRollBonus:0,sel:null}; }
function buildGauntlet(){ const j=shuffle([...SUITS]).map(s=>({rank:'J',suit:s})); const q=shuffle([...SUITS]).map(s=>({rank:'Q',suit:s})); const k=shuffle([...SUITS]).map(s=>({rank:'K',suit:s})); return[...j,...q,...k,{rank:'X',suit:'X'},{rank:'X',suit:'X'}]; }
function labelCard(c){return c.rank==='X'?'Joker':`${c.rank}${c.suit}`}

let S={ heroes:{A:makeHero('Knight'),B:makeHero('Mage')}, boss:null, gauntlet:buildGauntlet(), gi:0, carry:{dmg:0,poi:0}, lastTarget:null, lastFinisher:null, legendaryClaimed:false };

/* ====== Toast & Log ====== */
function toast(msg,kind='info'){ const d=document.createElement('div'); d.className='toast '+(kind==='bad'?'bad':kind==='good'?'good':''); d.textContent=msg; $('toasts').appendChild(d); setTimeout(()=>{d.style.opacity='0';d.style.transition='opacity .35s';},2600); setTimeout(()=>d.remove(),3000); }
function logLine(t){ const el=document.createElement('div'); el.className='line'; el.textContent=t; const log=$('bossLog'); log.prepend(el); while(log.children.length>8) log.removeChild(log.lastChild); }

/* ====== Boss lifecycle ====== */
function setBoss(i){
  S.gi=i; const c=S.gauntlet[i], d=bossDefs[c.rank];
  S.boss={rank:c.rank,suit:c.suit,name:d.name,hp:d.hp,max:d.hp,atk:d.atk,round:1,poi:0,jplus:false,x2:false};
  if(S.carry.dmg>0) S.boss.hp=Math.max(0,S.boss.hp-S.carry.dmg);
  if(S.carry.poi>0) S.boss.poi+=S.carry.poi;
  if(S.carry.dmg||S.carry.poi) toast(`Carry-over → −${S.carry.dmg||0} DMG, +${S.carry.poi||0} POI`,'good');
  S.carry={dmg:0,poi:0}; S.lastTarget=null; S.lastFinisher=null; S.legendaryClaimed=false;
  for(const k of ['A','B']){ const h=S.heroes[k]; h.plays=CFG.BASE_PLAYS; h.playsMax=CFG.BASE_PLAYS; h.diamond=0; h.shield=0; drawUp(k); }
  renderAll();
}
function nextBoss(){ if(S.gi<S.gauntlet.length-1) setBoss(S.gi+1); else{ toast('Gauntlet complete! New run.','good'); S.gauntlet=buildGauntlet(); setBoss(0); } }
function currBoss(){ return S.boss; }

/* ====== Draw & Render ====== */
function drawOne(k){ const h=S.heroes[k]; if(h.deck.length===0){ if(h.discard.length===0) return false; h.deck=shuffle(h.discard.splice(0)); } h.hand.push(h.deck.pop()); return true; }
function drawUp(k,n=4){ const h=S.heroes[k]; while(h.hand.length<n && (h.deck.length||h.discard.length)) drawOne(k); }
function renderBossBar(){ const pct=S.boss.max? (S.boss.hp/S.boss.max)*100 : 0; $('hpBar').style.width=Math.max(0,Math.min(100,pct))+'%'; $('hpNow').textContent=S.boss.hp; $('hpMax').textContent=S.boss.max; }
function renderAll(){
  const b=S.boss; $('bossName').textContent=`${b.name} (${b.rank}${b.rank==='X'?'':b.suit})`; $('bossStats').textContent=`HP ${b.hp}/${b.max} • DMG ${b.atk}`;
  $('poiVal').textContent=b.poi; $('roundOut').textContent=b.round; $('prog').textContent='Run: '+S.gauntlet.map((c,i)=>i===S.gi?`[${labelCard(c)}]`:labelCard(c)).join(' → ');
  renderBossBar(); renderHero('A'); renderHero('B');
}
function renderHero(k){
  const h=S.heroes[k];
  $(`hp${k}`).textContent=h.hp; $(`deckCount${k}`).textContent=h.deck.length; $(`discCount${k}`).textContent=h.discard.length; $(`handCount${k}`).textContent=h.hand.length; $(`plays${k}`).textContent=h.plays;
  $(`suits${k}`).textContent=`(${classMods[h.cls].suits.join(' ')})`;
  const chip=$(`assistChip${k}`); chip.style.display=h.nextRollBonus>0?'inline-block':'none'; if(h.nextRollBonus>0) chip.textContent=`Assist +${h.nextRollBonus}`;
  const zone=$(`hand${k}`); zone.innerHTML='';
  h.hand.forEach((c,i)=>{ const el=document.createElement('div'); el.className='cardlet'+(h.sel===i?' sel':''); el.textContent=(c.type==='num')?`${c.v}${c.s}`:`${c.rank}${c.s}`; el.onclick=()=>{ h.sel=(h.sel===i?null:i); renderHero(k); }; zone.appendChild(el); });
}

/* ====== Party helpers ====== */
function partnerKey(k){ return k==='A'?'B':'A'; }
function lowestHero(){ const A=S.heroes.A,B=S.heroes.B; if(A.hp<=0 && B.hp>0) return A; if(B.hp<=0 && A.hp>0) return B; return (A.hp<=B.hp)?A:B; }
function lowestAlive(){ const A=S.heroes.A.hp>0?S.heroes.A:null, B=S.heroes.B.hp>0?S.heroes.B:null; if(A&&B) return (A.hp<=B.hp)?A:B; return A||B; }
function teamHurt(n){ const t=lowestAlive(); if(!t) return; t.hp=clamp(t.hp-n,0,t.maxHP); if(t.hp<=0) t.down=true; }
function teamHeal(n){ const t=lowestHero(); const was=t.down||t.hp<=0; t.hp=clamp(t.hp+n,0,t.maxHP); if(was && t.hp>0){ t.down=false; toast('Revived lowest-HP hero','good'); } }
function addPlay(h){ const cap=CFG.CAP_DIAMOND+(classMods[h.cls].diamondCap||0); if(h.playsMax<CFG.BASE_PLAYS+cap){h.plays++;h.playsMax++;} }
function shield(n,h){ h.shield=(h.shield||0)+n }
function addPoison(n){ if(S.boss.hp>0) S.boss.poi+=n; else S.carry.poi+=n; }
function deal(n){ if(S.boss.hp>0){ S.boss.hp=Math.max(0,S.boss.hp-n); } else { S.carry.dmg+=n; } renderBossBar(); }
function autoTrashLowest(h,n=1){ const take=arr=>{let bi=-1,bv=99;arr.forEach((c,i)=>{if(c.type==='num'&&c.v<bv){bv=c.v;bi=i}}); if(bi>=0){arr.splice(bi,1);return true} return false}; for(let i=0;i<n;i++){ if(take(h.hand))continue; if(take(h.discard))continue; if(take(h.deck))continue; } }

/* ====== Boss mechanics ====== */
function bossAbility(){ const b=S.boss, r=d12(); if(b.rank==='J'){ b.jplus=(r<=3); return `J roll ${r}: ${b.jplus?'+2 DMG next attack':'no boost'}`; } if(b.rank==='Q'){ if(r<=3){ const g=Math.min(3,b.max-b.hp); b.hp+=g; renderBossBar(); return `Q roll ${r}: healed +${g}`; } return `Q roll ${r}: no heal`; } if(b.rank==='K'){ if(r<=2){ const p=b.poi; b.poi=0; return `K roll ${r}: purged ${p} poison`; } return `K roll ${r}: no purge`; } if(b.rank==='X'){ b.x2=(r>=8&&r<=10); return `Joker roll ${r}: ${b.x2?'x2 damage':'no double'}`; } return `roll ${r}`; }
function pickTarget(){ if(S.lastTarget===null) return S.heroes.A.hp>0?'A':(S.heroes.B.hp>0?'B':null); const o=S.lastTarget==='A'?'B':'A'; if(S.heroes[o].hp>0) return o; if(S.heroes[S.lastTarget].hp>0) return S.lastTarget; return null; }
function bossAttack(){ if(S.boss.hp<=0) return 'Boss is down'; let dmg=S.boss.atk; if(S.boss.rank==='J'&&S.boss.jplus)dmg+=2; if(S.boss.rank==='X'&&S.boss.x2)dmg*=2; const t=pickTarget(); if(!t) return 'No living targets'; const h=S.heroes[t]; const taken=Math.max(0,dmg-h.shield); h.shield=0; h.hp=clamp(h.hp-taken,0,h.maxHP); S.lastTarget=t; if(h.hp<=0 && !h.down){ h.down=true; toast(`Hero ${t} defeated!`,'bad'); } return `Boss targeted ${t} (alternating) and dealt ${taken}`; }
function nextRound(){ S.boss.round++; S.boss.jplus=false; S.boss.x2=false; for(const k of ['A','B']){ const h=S.heroes[k]; h.plays=CFG.BASE_PLAYS; h.playsMax=CFG.BASE_PLAYS; h.diamond=0; drawUp(k); } renderAll(); }
function bossPhase(){
  if(S.boss.poi>0){ const pre=S.boss.hp; S.boss.hp=Math.max(0,S.boss.hp-S.boss.poi); renderBossBar(); if(pre!==S.boss.hp){ const t=pre-S.boss.hp; toast(`Poison ticks for ${t}`,'good'); logLine(`Poison: −${t} HP`); } if(S.boss.hp<=0){ S.lastFinisher={via:'poison',who:null,suit:null}; onBossDefeated('by Poison'); return; } }
  const a=bossAbility(); logLine(`Ability → ${a}`); toast(`Royal ability: ${a}`);
  const atk=bossAttack(); logLine(`Attack → ${atk}`); toast(`Royal attack: ${atk}`);
  if(S.boss.hp<=0){ onBossDefeated('defeated'); return; }
  nextRound();
}

/* ====== Play & Assist ====== */
function playSelected(k){
  const h=S.heroes[k]; if(h.down){toast(`Hero ${k} is defeated.`,'bad');return}
  if(h.plays<=0){toast(`Hero ${k} has no plays.`,'bad');return}
  const idx=h.sel; if(idx==null){toast(`Select a card in ${k}'s hand first.`,'bad');return}
  const [card]=h.hand.splice(idx,1); h.discard.push(card); h.sel=null;

  const outR=$(`rollOut${k}`), outT=$(`result${k}`);
  if(card.type==='face'){
    const key=`${card.rank}${card.s}`, eff=(legendaryEffects[h.cls]||{})[key]; outR.textContent=`FACE ${key}`; if(typeof eff==='function') eff(h); outT.textContent='Legendary played'; h.plays--;
    if(S.boss.hp<=0){ S.lastFinisher={via:'hit',who:k,suit:card.s}; onBossDefeated('by damage'); return; }
    renderAll(); maybeBossPhase(); return;
  }

  const raw=d12(), bonus=h.nextRollBonus||0, r=Math.min(11, raw+bonus); h.nextRollBonus=0;
  outR.textContent=`d12: ${raw}${bonus?` (+${bonus}) = ${r}`:''}`;
  if(r>card.v){ h.plays--; outT.textContent=`Miss (${card.v}${card.s})`; renderAll(); maybeBossPhase(); return; }

  h.plays--;
  let dmg=CFG.DMG; if(r===1) dmg += (1 + (classMods[h.cls].lucky||0));
  deal(dmg);
  let tag=`Hit −${dmg} with ${card.v}${card.s}`;
  if(card.s==='♣'){ shield(CFG.SHIELD+(classMods[h.cls].shield||0),h); tag+=` • ♣ Guard +${CFG.SHIELD+(classMods[h.cls].shield||0)}`; }
  else if(card.s==='♥'){ teamHeal(CFG.HEAL+(classMods[h.cls].heal||0)); tag+=` • ♥ Heal lowest +${CFG.HEAL+(classMods[h.cls].heal||0)}`; }
  else if(card.s==='♠'){ addPoison(CFG.POI+(classMods[h.cls].poi||0)); tag+=` • ♠ POI +${CFG.POI+(classMods[h.cls].poi||0)}`; }
  else if(card.s==='♦'){ addPlay(h); tag+=' • ♦ +1 play'; }
  outT.textContent=tag;

  if(S.boss.hp<=0){ S.lastFinisher={via:'hit',who:k,suit:card.s}; onBossDefeated('by damage'); return; }
  renderAll(); maybeBossPhase();
}
function maybeBossPhase(){ const A=S.heroes.A, B=S.heroes.B; if((A.plays<=0||A.down) && (B.plays<=0||B.down)) bossPhase(); }

let assistFrom=null, assistSel=new Set();
function openAssist(k){
  assistFrom=k; assistSel=new Set(); $('assistOverlay').classList.add('show');
  const zone=$('assistPickZone'); zone.innerHTML='';
  const h=S.heroes[k];
  h.hand.forEach((c,i)=>{ const el=document.createElement('div'); el.className='cardlet'; el.textContent=(c.type==='num')?`${c.v}${c.s}`:`${c.rank}${c.s}`; el.onclick=()=>{ assistSel.has(i)?assistSel.delete(i):assistSel.add(i); el.classList.toggle('sel'); updateAssistSummary(); }; zone.appendChild(el); });
  updateAssistSummary();
}
function closeAssist(){ $('assistOverlay').classList.remove('show'); assistFrom=null; assistSel.clear(); }
function updateAssistSummary(){ const n=assistSel.size; $('assistSummary').textContent=`${n} selected → +${Math.min(CFG.ASSIST_CAP,n)} to partner`; }
function confirmAssist(){
  if(!assistFrom) return;
  const h=S.heroes[assistFrom]; if(h.down||h.plays<=0){ toast('Cannot assist now','bad'); return; }
  const n=assistSel.size; if(n===0){ toast('Select at least 1 card','bad'); return; }
  Array.from(assistSel).sort((a,b)=>b-a).forEach(i=>{ h.discard.push(h.hand[i]); h.hand.splice(i,1); });
  h.plays--; const p=S.heroes[partnerKey(assistFrom)]; p.nextRollBonus=Math.min(CFG.ASSIST_CAP,(p.nextRollBonus||0)+Math.min(CFG.ASSIST_CAP,n));
  toast(`Hero ${assistFrom} assists partner: +${Math.min(CFG.ASSIST_CAP,n)} to next d12`,'good'); logLine(`Assist: ${assistFrom} → +${Math.min(CFG.ASSIST_CAP,n)} partner roll`);
  closeAssist(); renderAll(); maybeBossPhase();
}

/* ====== Rewards (auto-assign on hit; choose on poison) ====== */
function addUpgrade(h,rank,suit){ const map={J:6,Q:7,K:8,X:9}; let v=map[rank], s=suit; if(rank==='X') s=SUITS[Math.floor(Math.random()*SUITS.length)]; h.discard.push({type:'num',v,s}); toast(`${h===S.heroes.A?'Hero A':'Hero B'}: +${v}${s} (upgrade)`,'good'); }

function grantLegendaryTo(k){
  const b=S.boss, h=S.heroes[k], key=`${b.rank}${b.suit}`;
  h.discard.push({type:'face',rank:b.rank,s:b.suit});
  toast(`Legendary auto-granted to Hero ${k}: ${key}`,'good');
  logLine(`Legendary → ${key} → Hero ${k}`);
  S.legendaryClaimed = true;
}

function tryAutoGrantLegendary(){
  const b=S.boss, f=S.lastFinisher;
  if(!f || b.rank==='X') return false;
  if(f.via==='hit' && f.suit===b.suit){ grantLegendaryTo(f.who); return true; }
  return false; // poison handled in modal
}

function onBossDefeated(reason='defeated'){
  toast(`Royal ${reason} — rewards ready.`,'good');
  addUpgrade(S.heroes.A,S.boss.rank,S.boss.suit);
  addUpgrade(S.heroes.B,S.boss.rank,S.boss.suit);

  // Auto-assign if hit kill matches suit
  const auto = tryAutoGrantLegendary();

  // Build finisher note
  const f=S.lastFinisher;
  const note = (!f) ? '' :
    (f.via==='poison' ? 'Finisher: Poison — choose one hero to claim Legendary.' :
     `Finisher: ${f.who} with ${f.suit}${(S.boss.rank==='X')?' (Joker — no Legendary)':''}`);

  $('rewHint').innerHTML =
    `Each hero auto-adds: J→6, Q→7, K→8, Joker→9 (to discard).<br/><b>Legendary:</b> Killing blow with <b>matching suit</b> auto-grants to that hero. If <b>poison</b> killed, either hero may claim (one total). Jokers grant no Legendary.<br/><span class="sub">${note}</span>`;

  openRewards();
}

function openRewards(){ buildChoices('A'); buildChoices('B'); $('rewardsOverlay').classList.add('show'); }
function closeRewards(){ $('rewardsOverlay').classList.remove('show'); }

function buildChoices(k){
  const holder=$('choices'+k); holder.innerHTML='';
  const h=S.heroes[k], b=S.boss, f=S.lastFinisher;

  // If already auto-granted on hit, both sides show only generics
  const autoGranted = S.legendaryClaimed && f && f.via==='hit';
  const poisonClaimAvailable = f && f.via==='poison' && b.rank!=='X' && !S.legendaryClaimed;

  if(poisonClaimAvailable){
    const key=`${b.rank}${b.suit}`;
    const btn=document.createElement('button'); btn.className='btn green'; btn.textContent=`Claim ${key} (Legendary)`;
    btn.onclick=()=>{ if(S.legendaryClaimed) return; grantLegendaryTo(k); // mark & rebuild other pane to disable
      buildChoices(k==='A'?'B':'A'); btn.disabled=true; btn.textContent='Claimed'; };
    holder.appendChild(btn);
    const info=document.createElement('div'); info.className='sub'; info.style.marginTop='6px'; info.textContent='Poison finisher: either hero may claim (one total).'; holder.appendChild(info);
  } else if(!autoGranted && b.rank!=='X' && f && f.via==='hit' && f.who===k && f.suit===b.suit){
    // (Should not happen because we auto-grant, but keep a safety path)
    const key=`${b.rank}${b.suit}`;
    const btn=document.createElement('button'); btn.className='btn green'; btn.textContent=`Add ${key} to deck (Legendary)`;
    btn.onclick=()=>{ grantLegendaryTo(k); btn.disabled=true; btn.textContent='Added'; };
    holder.appendChild(btn);
  } else if(autoGranted) {
    const note=document.createElement('div'); note.className='sub'; note.textContent=`Legendary auto-granted to Hero ${f.who}.`; holder.appendChild(note);
  }

  // Generics (always available)
  (GENERIC_BY_RANK[b.rank]||[]).forEach(id=>{
    const g=GENERICS_ALL[id];
    const tag=document.createElement('button'); tag.className='tag'; tag.textContent=g.label+' + Trash 1';
    tag.onclick=()=>{ g.run(h); autoTrashLowest(h,1); tag.disabled=true; tag.textContent='Used'; renderAll(); toast(`Hero ${k}: Generic + trash lowest`,'good'); };
    holder.appendChild(tag);
  });
}

document.getElementById('ackRewards').addEventListener('click',()=>{ closeRewards(); nextBoss(); });
document.getElementById('closeRewards').addEventListener('click', closeRewards);

/* ====== Controls & init ====== */
function resetGame(){ const clsA=S.heroes.A.cls, clsB=S.heroes.B.cls; S={ heroes:{A:makeHero(clsA),B:makeHero(clsB)}, boss:null, gauntlet:buildGauntlet(), gi:0, carry:{dmg:0,poi:0}, lastTarget:null, lastFinisher:null, legendaryClaimed:false }; setBoss(0); toast('New game started','good'); }

function init(){
  if('serviceWorker' in navigator){ navigator.serviceWorker.register('sw.js'); }
  document.addEventListener('touchstart',()=>{}, {passive:true});
  document.getElementById('poiPlus').onclick=()=>{ S.boss.poi++; renderAll(); };
  document.getElementById('poiMinus').onclick=()=>{ S.boss.poi=Math.max(0,S.boss.poi-1); renderAll(); };
  document.getElementById('resetBoss').onclick=resetGame;
  document.getElementById('newRunBtn').onclick=()=>{ S.gauntlet=buildGauntlet(); setBoss(0); S.lastTarget=null; toast('New run: fresh gauntlet order','good'); };

  for(const k of ['A','B']){
    document.getElementById(`class${k}`).onchange=e=>{ const h=S.heroes[k]; const r=h.hp/h.maxHP||1; h.cls=e.target.value; h.maxHP=classMods[h.cls].maxHP; h.hp=clamp(Math.round(h.maxHP*r),0,h.maxHP); renderHero(k); };
    document.getElementById(`hp${k}Minus`).onclick=()=>{ const h=S.heroes[k]; h.hp=clamp(h.hp-1,0,h.maxHP); if(h.hp<=0&&!h.down){h.down=true;toast(`Hero ${k} defeated!`,'bad')} renderHero(k); };
    document.getElementById(`hp${k}Plus`).onclick =()=>{ const h=S.heroes[k]; const was=h.down; h.hp=clamp(h.hp+1,0,h.maxHP); if(was&&h.hp>0){ h.down=false; toast(`Hero ${k} revived`,'good'); } renderHero(k); };
    document.getElementById(`roll${k}`).onclick =()=>playSelected(k);
    document.getElementById(`assist${k}`).onclick =()=>openAssist(k);
  }
  document.getElementById('assistClose').onclick=closeAssist;
  document.getElementById('assistConfirm').onclick=confirmAssist;

  setBoss(0);
  renderAll();
}
init();
</script>
</body>
</html>
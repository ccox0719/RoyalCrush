<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Royal Crush — Mobile (Deck & PWA)</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#0f1115">
<style>
  :root{
    --bg:#0f1115; --panel:#171a21; --ink:#e9eef6; --sub:#aab3c2;
    --line:#272c3b; --chip:#141a24; --chipline:#293143;
    --accent:#60a5fa; --good:#34d399; --warn:#f59e0b; --bad:#ef4444; --overlay:rgba(0,0,0,.55);
  }
  *{box-sizing:border-box}
  body{margin:0;background:#0f1115;color:#e9eef6;font:15px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
  .wrap{max-width:980px;margin:0 auto;padding:14px}
  h1{margin:0 0 10px;font-size:20px}
  .card{background:#171a21;border:1px solid var(--line);border-radius:14px;padding:14px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .between{display:flex;justify-content:space-between;align-items:center}
  .bar{height:12px;background:#0e1420;border:1px solid #283045;border-radius:999px;overflow:hidden}
  .bar>span{display:block;height:100%;background:linear-gradient(90deg,var(--accent),var(--good))}
  .sub{color:var(--sub);font-size:12px}
  .btn{padding:9px 12px;border-radius:12px;border:1px solid var(--line);background:#151924;color:#e9eef6;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .btn.red{background:#2a1215;border-color:#3a1a1e}
  .btn.green{background:#13301f;border-color:#1b3e29}
  .btn.gray{background:#141922;border-color:#252c3c}
  .mini{padding:2px 8px;font-size:11px}
  input,select{width:100%;padding:9px;border-radius:10px;border:1px solid var(--line);background:#0f131b;color:#e9eef6}
  .chip{background:var(--chip);border:1px solid var(--chipline);border-radius:999px;padding:4px 8px;font-size:12px;color:#cfe3ff}
  .chip.bad{border-color:#5a1d21;background:#2a1516;color:#ffd6d6}
  .chip.good{border-color:#1f3e29;background:#132018;color:#d7ffe3}
  .mono{font-family:ui-monospace,Consolas,Menlo,monospace}
  .step{margin-top:10px}
  .step>h2{margin:0 0 8px;font-size:14px;color:#cfe3ff}
  .hand{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
  .cardlet{min-width:40px;padding:8px;border-radius:8px;border:1px solid #2b3244;background:#121722;cursor:pointer}
  .cardlet.sel{outline:2px solid #60a5fa; outline-offset:2px}
  .stack{display:flex;gap:8px; align-items:center}
  .stack .chip{min-width:44px;text-align:center}
  .hide{display:none}
  /* Toasts */
  .toasts{position:fixed; top:12px; right:12px; display:flex; flex-direction:column; gap:8px; z-index:9999}
  .toast{background:#121722;border:1px solid #2b3142;border-radius:10px;padding:10px 12px; box-shadow:0 8px 24px rgba(0,0,0,.35)}
  .toast.bad{border-color:#5a1d21;background:#281215}
  .toast.good{border-color:#1f3e29;background:#132018}
  /* Modal */
  .overlay{position:fixed; inset:0; background:var(--overlay); display:none; align-items:center; justify-content:center; z-index:9998}
  .overlay.show{display:flex}
  .modal{width:min(920px,94vw); max-height:86vh; overflow:auto; background:#151922; border:1px solid #2a3040; border-radius:14px; box-shadow:0 18px 48px rgba(0,0,0,.5); padding:14px}
  .modal h3{margin:0 0 8px; font-size:16px}
  .grid{display:grid; gap:10px}
  .g2{grid-template-columns:1fr 1fr}
  .g3{grid-template-columns:repeat(3,1fr)}
  .list{border:1px solid #2a3142; border-radius:10px; padding:10px}
  .tag{display:inline-block; border:1px solid #2b3142; border-radius:6px; padding:3px 6px; margin:3px; font-size:12px; background:#121723}
</style>
</head>
<body>
<div class="wrap">
  <h1>Royal Crush — Two-Hero (Deck Play)</h1>
  <div class="toasts" id="toasts"></div>

  <!-- Boss Panel -->
  <div class="card">
    <div class="between">
      <div>
        <div class="sub">Royal</div>
        <div style="font-size:20px;font-weight:700" id="bossName">—</div>
        <div class="sub" id="bossStats">HP — • DMG —</div>
      </div>
      <div style="text-align:right">
        <div class="sub">Boss HP</div>
        <div class="row" style="justify-content:flex-end">
          <div style="font-size:22px;font-weight:700">
            <span id="hpNow">0</span>/<span id="hpMax">0</span>
          </div>
          <div class="chip">POI: <span id="poiVal">0</span></div>
          <button class="btn mini" id="poiPlus">+1</button>
          <button class="btn mini" id="poiMinus">-1</button>
        </div>
      </div>
    </div>
    <div class="bar" style="margin:8px 0 10px"><span id="hpBar" style="width:0%"></span></div>

    <!-- Step 1: Hero A -->
    <div class="step">
      <h2>Step 1 — Hero A acts</h2>
      <div class="row">
        <select id="classA">
          <option>Knight</option><option>Mage</option><option>Assassin</option><option>Priest</option>
        </select>
        <div class="chip">HP: <span id="hpA">35</span></div>
        <button class="btn mini" id="hpAMinus">-1</button>
        <button class="btn mini" id="hpAPlus">+1</button>
        <div class="chip hide" id="statusA"></div>
        <button class="btn gray mini" id="editDeckA">Deck</button>
      </div>

      <div class="stack" style="margin-top:4px">
        <div class="chip">Deck <span id="deckCountA">0</span></div>
        <div class="chip">Discard <span id="discCountA">0</span></div>
        <div class="chip">Hand <span id="handCountA">0</span></div>
        <button class="btn mini" id="drawA">Draw Up</button>
        <button class="btn mini" id="discardA">Discard Sel</button>
        <button class="btn mini" id="trashA">Trash Sel</button>
      </div>

      <div id="handA" class="hand"></div>

      <div class="row" style="margin-top:6px">
        <button class="btn" id="rollA">Play Selected & Roll d12</button>
        <div class="chip mono" id="rollOutA">—</div>
        <div class="chip mono" id="resultA">—</div>
      </div>
    </div>

    <!-- Step 2: Hero B -->
    <div class="step">
      <h2>Step 2 — Hero B acts</h2>
      <div class="row">
        <select id="classB">
          <option>Knight</option><option selected>Mage</option><option>Assassin</option><option>Priest</option>
        </select>
        <div class="chip">HP: <span id="hpB">30</span></div>
        <button class="btn mini" id="hpBMinus">-1</button>
        <button class="btn mini" id="hpBPlus">+1</button>
        <div class="chip hide" id="statusB"></div>
        <button class="btn gray mini" id="editDeckB">Deck</button>
      </div>

      <div class="stack" style="margin-top:4px">
        <div class="chip">Deck <span id="deckCountB">0</span></div>
        <div class="chip">Discard <span id="discCountB">0</span></div>
        <div class="chip">Hand <span id="handCountB">0</span></div>
        <button class="btn mini" id="drawB">Draw Up</button>
        <button class="btn mini" id="discardB">Discard Sel</button>
        <button class="btn mini" id="trashB">Trash Sel</button>
      </div>

      <div id="handB" class="hand"></div>

      <div class="row" style="margin-top:6px">
        <button class="btn" id="rollB">Play Selected & Roll d12</button>
        <div class="chip mono" id="rollOutB">—</div>
        <div class="chip mono" id="resultB">—</div>
      </div>
    </div>

    <!-- Step 3: Boss ability -->
    <div class="step">
      <h2>Step 3 — Boss ability (optional)</h2>
      <div class="row">
        <button class="btn" id="abilityBtn">Roll Ability (d12)</button>
        <div class="chip mono" id="abilityOut">—</div>
      </div>
    </div>

    <!-- Step 4: Boss turn -->
    <div class="step">
      <h2>Step 4 — Boss Turn → Next Round</h2>
      <div class="row">
        <select id="bossTarget">
          <option value="AUTO" selected>Target: Auto (lowest HP)</option>
          <option value="A">Target: Hero A</option>
          <option value="B">Target: Hero B</option>
        </select>
        <button class="btn red" id="bossTurnBtn">Boss Turn → Next Round</button>
        <div class="chip mono" id="roundOut">R1</div>
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <div class="sub">Change Royal:</div>
      <div class="row" id="bossButtons"></div>
    </div>
    <div class="sub" style="margin-top:6px;opacity:.8">J 8/2 (≤3 +2) • Q 14/4 (≤3 heal3) • K 18/5 (≤2 purge) • Joker 26/6 (8–10 ×2)</div>
  </div>

  <!-- Footer -->
  <div class="row" style="margin-top:10px">
    <button class="btn gray" id="clearSaveBtn">Clear Save</button>
    <button class="btn gray" id="resetBoss">Reset Royal</button>
    <label class="row" style="gap:6px;margin-left:auto">
      <input type="checkbox" id="perfModeChk" />
      <span class="sub">Performance Mode</span>
    </label>
  </div>
</div>

<!-- Deck Editor Modal -->
<div class="overlay" id="deckOverlay" role="dialog" aria-modal="true" aria-labelledby="deckTitle">
  <div class="modal">
    <div class="between" style="margin-bottom:8px">
      <h3 id="deckTitle">Edit Deck — Hero</h3>
      <button class="btn" id="closeDeck">Close</button>
    </div>
    <div class="sub" style="margin-bottom:6px">Tap +/− to change counts. Changes apply immediately.</div>
    <div id="deckGrid" class="grid g3"></div>
    <div class="row" style="margin-top:8px">
      <button class="btn gray" id="shuffleDeck">Shuffle Deck</button>
      <button class="btn gray" id="resetStart">Reset to Start (2–5, one of each suit)</button>
    </div>
  </div>
</div>

<script>
/* -------------------- Rules & Data -------------------- */
const bosses = [
  {id:'jack',  label:'J♣J♠J♥J♦', name:'Jacks',  maxHP:8,  atk:2},
  {id:'queen', label:'Q♣Q♠Q♥Q♦', name:'Queens', maxHP:14, atk:4},
  {id:'king',  label:'K♣K♠K♥K♦', name:'Kings',  maxHP:18, atk:5},
  {id:'joker', label:'Jokers',   name:'Jokers', maxHP:26, atk:6},
];

const DMG_PER_HIT = 5;          // fixed damage
const BASE_PLAYS = 1;           // plays per hero per round; ♦ grants +1 (cap 2, Mage cap 3)
const BASE_DIAMOND_CAP = 2;
const BASE_SHIELD = 3;          // Knight +1
const BASE_HEAL = 3;            // Priest +1
const BASE_POI = 1;             // Assassin +1

const mods = {
  Knight:{ maxHP:35, diamondCap:+0, lucky:+0, shield:+1, heal:+0, poi:+0 },
  Mage:{   maxHP:30, diamondCap:+1, lucky:+1, shield:+0, heal:+0, poi:+0 },
  Assassin:{maxHP:30,diamondCap:+0, lucky:+0, shield:+0, heal:+0, poi:+1 },
  Priest:{ maxHP:35, diamondCap:+0, lucky:+0, shield:+0, heal:+1, poi:+0 },
};

const SUITS = ['♣','♠','♥','♦'];
const VALUES = [2,3,4,5,6,7,8,9]; // cap at 9 per your crit rule

/* -------------------- State -------------------- */
let S = {
  perf:false,
  boss:{ id:'jack', name:'Jacks', hp:8, maxHP:8, atk:2, round:1, poison:0, jackPlus2:false, jokerTimes2:false },
  A: makeHero('Knight'),
  B: makeHero('Mage'),
  selectedA: null, // index in hand
  selectedB: null
};

function makeHero(cls){
  return {
    cls, hp:mods[cls].maxHP, maxHP:mods[cls].maxHP,
    plays:BASE_PLAYS, playsMax:BASE_PLAYS, diamond:0, shield:0, down:false,
    deck: startDeck(), discard: [], hand:[]
  };
}

function startDeck(){
  // one copy each: suits x values 2–5 (16 cards)
  const d=[];
  [2,3,4,5].forEach(v=> SUITS.forEach(s=> d.push({v,s})));
  return shuffle(d);
}

/* -------------------- Utilities -------------------- */
const $=id=>document.getElementById(id);
const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
const d12=()=>Math.floor(Math.random()*12)+1;
const lucky=h=>1+(mods[h.cls]?.lucky||0);
const shieldVal=h=>BASE_SHIELD+(mods[h.cls]?.shield||0);
const healVal=h=>BASE_HEAL+(mods[h.cls]?.heal||0);
const poiVal=h=>BASE_POI+(mods[h.cls]?.poi||0);
const capPlays=h=>BASE_DIAMOND_CAP+(mods[h.cls]?.diamondCap||0);

function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}
function toast(msg, kind='info'){
  const box = document.createElement('div');
  box.className = 'toast ' + (kind==='bad'?'bad':kind==='good'?'good':'');
  box.textContent = msg;
  $('toasts').appendChild(box);
  setTimeout(()=>{ box.style.opacity='0'; box.style.transition='opacity .35s'; }, 2600);
  setTimeout(()=>{ box.remove(); }, 3000);
}

/* -------------------- Save/Load -------------------- */
function save(){ try{ localStorage.setItem('rc.pwa.deck', JSON.stringify(S)); }catch{} }
function load(){
  const raw = localStorage.getItem('rc.pwa.deck'); if(!raw) return;
  try{
    const loaded = JSON.parse(raw);
    S = {...S, ...loaded};
    // enforce 1-play & hand integrity
    ['A','B'].forEach(k=>{
      S[k].plays=BASE_PLAYS; S[k].playsMax=BASE_PLAYS; S[k].diamond=0;
      if(!Array.isArray(S[k].deck)) S[k].deck = startDeck();
      if(!Array.isArray(S[k].discard)) S[k].discard=[];
      if(!Array.isArray(S[k].hand)) S[k].hand=[];
    });
  }catch{}
}

/* -------------------- Rendering -------------------- */
function render(){
  // Boss
  $('bossName').textContent = S.boss.name;
  $('bossStats').textContent = `HP ${S.boss.hp}/${S.boss.maxHP} • DMG ${S.boss.atk}`;
  $('hpNow').textContent = S.boss.hp;
  $('hpMax').textContent = S.boss.maxHP;
  $('hpBar').style.width = Math.max(0,Math.min(100,(S.boss.hp/S.boss.maxHP)*100))+'%';
  $('poiVal').textContent = S.boss.poison;
  $('roundOut').textContent = 'R'+S.boss.round;

  // Heroes
  renderHero('A');
  renderHero('B');

  save();
}
function renderHero(w){
  const h = S[w];
  $('hp'+w).textContent = h.hp;
  $('status'+w).textContent = heroStatus(h);
  $('status'+w).classList.toggle('hide', $('status'+w).textContent==='');

  // counts
  $('deckCount'+w).textContent = h.deck.length;
  $('discCount'+w).textContent = h.discard.length;
  $('handCount'+w).textContent = h.hand.length;

  // hand
  const zone = $('hand'+w);
  zone.innerHTML = '';
  h.hand.forEach((c,idx)=>{
    const el = document.createElement('button');
    el.className = 'cardlet btn';
    if((w==='A' && S.selectedA===idx) || (w==='B' && S.selectedB===idx)) el.classList.add('sel');
    el.textContent = `${c.v}${c.s}`;
    el.addEventListener('click', ()=>{
      if(w==='A'){ S.selectedA = (S.selectedA===idx?null:idx); }
      else { S.selectedB = (S.selectedB===idx?null:idx); }
      render();
    });
    zone.appendChild(el);
  });

  // disable roll if down or no plays or no selected
  const disabled = h.down || h.plays<=0 || (w==='A'?S.selectedA:S.selectedB)===null;
  $('roll'+w).classList.toggle('disabled', disabled);
  $('roll'+w).disabled = disabled;
}
function heroStatus(h){
  const bits=[];
  if(h.down) bits.push('DOWN');
  if(h.shield>0) bits.push(`Shield ${h.shield}`);
  if(h.playsMax>BASE_PLAYS) bits.push(`Plays ${h.plays}/${h.playsMax}`);
  return bits.join(' • ');
}

/* -------------------- Boss controls -------------------- */
function pickBoss(id){
  const b = bosses.find(x=>x.id===id);
  S.boss = { id:b.id, name:b.name, hp:b.maxHP, maxHP:b.maxHP, atk:b.atk, round:1, poison:0, jackPlus2:false, jokerTimes2:false };
  // new round
  ['A','B'].forEach(k=>{ S[k].plays=BASE_PLAYS; S[k].playsMax=BASE_PLAYS; S[k].diamond=0; S[k].shield=0; });
  render();
}
function bossAbility(){
  const r = d12();
  let msg = `d12: ${r} • DMG ${S.boss.atk}`;
  if(S.boss.id==='jack'){ S.boss.jackPlus2 = (r<=3); msg = S.boss.jackPlus2?`d12: ${r} • DMG ${S.boss.atk+2} (base ${S.boss.atk}+2)`:msg; }
  else if(S.boss.id==='queen'){ if(r<=3){ S.boss.hp = clamp(S.boss.hp+3,0,S.boss.maxHP); msg = `d12: ${r} • Heal +3 • DMG ${S.boss.atk}`; } }
  else if(S.boss.id==='king'){ if(r<=2){ S.boss.poison=0; msg = `d12: ${r} • Purge POI • DMG ${S.boss.atk}`; } }
  else if(S.boss.id==='joker'){ S.boss.jokerTimes2 = (r>=8 && r<=10); msg = S.boss.jokerTimes2?`d12: ${r} • DMG ${S.boss.atk*2} (×2)`:msg; }
  $('abilityOut').textContent = msg;
  render();
}
function bossTurn(){
  // 1) Poison tick
  if(S.boss.poison>0){ S.boss.hp = clamp(S.boss.hp - S.boss.poison, 0, S.boss.maxHP); }
  if(S.boss.hp<=0){ bossDefeated('by Poison'); return; }

  // 2) Damage
  let dmg = S.boss.atk;
  if(S.boss.id==='jack' && S.boss.jackPlus2) dmg+=2;
  if(S.boss.id==='joker' && S.boss.jokerTimes2) dmg*=2;

  const tgtSel = $('bossTarget').value;
  const tgt = (tgtSel==='AUTO') ? ((S.A.hp<=S.B.hp)?'A':'B') : tgtSel;
  const h = S[tgt];
  const reduced = Math.max(0, dmg - h.shield);
  h.shield=0;
  h.hp = clamp(h.hp - reduced, 0, h.maxHP);
  $('abilityOut').textContent = `Boss dealt ${reduced} to ${tgt}`;

  if(h.hp<=0 && !h.down){ h.down=true; toast(`Hero ${tgt} defeated!`,'bad'); }

  // 3) Next round: reset plays, clear flags, auto draw up to 4
  S.boss.round += 1;
  S.boss.jackPlus2 = false; S.boss.jokerTimes2 = false;
  ['A','B'].forEach(k=>{ S[k].plays=BASE_PLAYS; S[k].playsMax=BASE_PLAYS; S[k].diamond=0; drawUp(k); });
  render();
}
function bossDefeated(reason){
  $('abilityOut').textContent = `Royal defeated ${reason}`;
  toast(`Royal defeated — claim rewards!`,'good');
  // simple: let players open deck editor to add cards; no auto-changes here
}

/* -------------------- Deck & Hand -------------------- */
function drawOne(w){
  const h=S[w];
  if(h.deck.length===0){ // reshuffle discard
    if(h.discard.length===0) return false;
    h.deck = shuffle(h.discard.splice(0));
  }
  const c = h.deck.pop();
  h.hand.push(c);
  return true;
}
function drawUp(w, size=4){
  const h=S[w];
  while(h.hand.length < size && (h.deck.length>0 || h.discard.length>0)){
    drawOne(w);
  }
}
function discardSelected(w){
  const h=S[w];
  const idx = (w==='A'?S.selectedA:S.selectedB);
  if(idx===null||idx===undefined) return;
  const [c] = h.hand.splice(idx,1);
  h.discard.push(c);
  if(w==='A') S.selectedA=null; else S.selectedB=null;
}
function trashSelected(w){
  const h=S[w];
  const idx = (w==='A'?S.selectedA:S.selectedB);
  if(idx===null||idx===undefined) return;
  h.hand.splice(idx,1);
  if(w==='A') S.selectedA=null; else S.selectedB=null;
}

/* -------------------- Playing a Card -------------------- */
function playAndRoll(w){
  const h=S[w];
  if(h.down){ toast(`Hero ${w} is defeated.`, 'bad'); return; }
  if(h.plays<=0){ toast(`Hero ${w} has no plays.`, 'bad'); return; }
  const idx = (w==='A'?S.selectedA:S.selectedB);
  if(idx===null||idx===undefined){ toast(`Select a card in ${w}'s hand first.`,'bad'); return; }

  // consume play and move card to discard
  const [card] = h.hand.splice(idx,1);
  h.discard.push(card);
  if(w==='A') S.selectedA=null; else S.selectedB=null;

  const val = card.v;
  const suit = card.s;

  const outR = $('rollOut'+w);
  const outT = $('result'+w);

  const r = d12();
  outR.textContent = `d12: ${r}`;

  // Fumble
  if(r===12){
    h.plays -= 1;
    h.hp = clamp(h.hp-1,0,h.maxHP);
    outT.textContent='Fumble (self-1)';
    if(h.hp<=0 && !h.down){ h.down=true; toast(`Hero ${w} defeated!`,'bad'); }
    render(); return;
  }
  // Miss
  if(r>val){
    h.plays -= 1;
    outT.textContent = `Miss (played ${val}${suit})`;
    render(); return;
  }

  // Hit!
  h.plays -= 1;
  let dmg = DMG_PER_HIT;
  if(r===1) dmg += lucky(h);
  S.boss.hp = clamp(S.boss.hp - dmg, 0, S.boss.maxHP);

  let tag = `Hit −${dmg} with ${val}${suit}`;

  if(suit==='♣'){ h.shield += shieldVal(h); tag += ` • ♣ Shield +${shieldVal(h)}`; }
  else if(suit==='♥'){ h.hp = clamp(h.hp + healVal(h), 0, h.maxHP); tag += ` • ♥ Heal +${healVal(h)}`; }
  else if(suit==='♠'){ S.boss.poison += poiVal(h); $('poiVal').textContent = S.boss.poison; tag += ` • ♠ POI +${poiVal(h)}`; }
  else if(suit==='♦'){
    // add a play up to cap
    const cap = capPlays(h);
    if(h.playsMax < BASE_PLAYS + cap){ h.plays += 1; h.playsMax += 1; tag += ` • ♦ +1 play`; }
  }

  outT.textContent = tag;

  if(S.boss.hp<=0){ bossDefeated('by damage'); }

  render();
}

/* -------------------- Deck Editor -------------------- */
let deckEditWho = 'A';
function openDeckEditor(w){
  deckEditWho = w;
  $('deckTitle').textContent = `Edit Deck — Hero ${w}`;
  rebuildDeckGrid();
  $('deckOverlay').classList.add('show');
}
function closeDeckEditor(){ $('deckOverlay').classList.remove('show'); }

function rebuildDeckGrid(){
  const w = deckEditWho;
  const h = S[w];
  // compute counts across deck+discard+hand for a full picture
  const all = [...h.deck, ...h.discard, ...h.hand];
  const counts = {};
  VALUES.forEach(v=> SUITS.forEach(s=> counts[`${v}${s}`] = 0));
  all.forEach(c=>{ const k=`${c.v}${c.s}`; counts[k] = (counts[k]||0)+1; });

  const grid = $('deckGrid'); grid.innerHTML='';
  VALUES.forEach(v=>{
    SUITS.forEach(s=>{
      const key = `${v}${s}`;
      const row = document.createElement('div');
      row.className='row';
      row.style.border='1px solid #2b3142'; row.style.borderRadius='8px'; row.style.padding='8px';
      row.innerHTML = `
        <div style="min-width:60px;font-weight:600">${v}${s}</div>
        <div class="chip">Count: <span id="cnt-${key}">${counts[key]||0}</span></div>
        <button class="btn mini" data-add="${key}">+1</button>
        <button class="btn mini" data-rem="${key}">-1</button>
      `;
      grid.appendChild(row);
    });
  });

  // wire buttons
  grid.querySelectorAll('[data-add]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const key = btn.getAttribute('data-add'); const v=parseInt(key); const s=key.replace(String(v),'');
      // add to discard (so deck order not disturbed) then update
      h.discard.push({v,s});
      document.getElementById('cnt-'+key).textContent = Number(document.getElementById('cnt-'+key).textContent)+1;
      render();
    });
  });
  grid.querySelectorAll('[data-rem]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const key = btn.getAttribute('data-rem'); const v=parseInt(key); const s=key.replace(String(v),'');
      // remove one from hand, else discard, else deck
      const rm = (arr)=>{ const i=arr.findIndex(c=>c.v===v && c.s===s); if(i>=0){ arr.splice(i,1); return true;} return false; };
      if(!rm(h.hand)) if(!rm(h.discard)) rm(h.deck);
      const span = document.getElementById('cnt-'+key);
      span.textContent = Math.max(0, Number(span.textContent)-1);
      render();
    });
  });
}

function shuffleCurrentDeck(){
  const h = S[deckEditWho];
  h.deck = shuffle(h.deck);
  toast(`Shuffled Hero ${deckEditWho}'s deck`,'good');
  render();
}
function resetToStart(){
  const h = S[deckEditWho];
  h.deck = startDeck(); h.discard=[]; h.hand=[];
  toast(`Reset Hero ${deckEditWho} to starting deck`,'good');
  render(); rebuildDeckGrid();
}

/* -------------------- Wire-up -------------------- */
function initBossButtons(){
  const c = $('bossButtons');
  bosses.forEach(b=>{
    const btn = document.createElement('button');
    btn.className='btn mini';
    btn.textContent = b.label;
    btn.addEventListener('click', ()=>pickBoss(b.id));
    c.appendChild(btn);
  });
}
function init(){
  // PWA hook (installable)
  if('serviceWorker' in navigator){ navigator.serviceWorker.register('sw.js'); }
  document.addEventListener('touchstart',()=>{}, {passive:true}); // iOS :active

  load();

  // Boss
  $('abilityBtn').addEventListener('click', bossAbility);
  $('bossTurnBtn').addEventListener('click', bossTurn);
  $('poiPlus').addEventListener('click', ()=>{ S.boss.poison+=1; render(); });
  $('poiMinus').addEventListener('click', ()=>{ S.boss.poison=Math.max(0,S.boss.poison-1); render(); });
  $('resetBoss').addEventListener('click', ()=>pickBoss(S.boss.id));
  initBossButtons();

  // Heroes meta
  $('classA').addEventListener('change', e=>classApply('A', e.target.value));
  $('classB').addEventListener('change', e=>classApply('B', e.target.value));
  $('hpAMinus').addEventListener('click', ()=>{ S.A.hp=clamp(S.A.hp-1,0,S.A.maxHP); if(S.A.hp<=0 && !S.A.down){S.A.down=true; toast('Hero A defeated!','bad');} render();});
  $('hpAPlus').addEventListener('click',  ()=>{ const wasDown=S.A.down; S.A.hp=clamp(S.A.hp+1,0,S.A.maxHP); if(wasDown && S.A.hp>0){S.A.down=false; toast('Hero A revived','good');} render();});
  $('hpBMinus').addEventListener('click', ()=>{ S.B.hp=clamp(S.B.hp-1,0,S.B.maxHP); if(S.B.hp<=0 && !S.B.down){S.B.down=true; toast('Hero B defeated!','bad');} render();});
  $('hpBPlus').addEventListener('click',  ()=>{ const wasDown=S.B.down; S.B.hp=clamp(S.B.hp+1,0,S.B.maxHP); if(wasDown && S.B.hp>0){S.B.down=false; toast('Hero B revived','good');} render();});

  // Deck controls A
  $('drawA').addEventListener('click', ()=>{ drawUp('A'); render(); });
  $('discardA').addEventListener('click', ()=>{ discardSelected('A'); render(); });
  $('trashA').addEventListener('click', ()=>{ trashSelected('A'); render(); });
  $('rollA').addEventListener('click', ()=>playAndRoll('A'));
  $('editDeckA').addEventListener('click', ()=>openDeckEditor('A'));

  // Deck controls B
  $('drawB').addEventListener('click', ()=>{ drawUp('B'); render(); });
  $('discardB').addEventListener('click', ()=>{ discardSelected('B'); render(); });
  $('trashB').addEventListener('click', ()=>{ trashSelected('B'); render(); });
  $('rollB').addEventListener('click', ()=>playAndRoll('B'));
  $('editDeckB').addEventListener('click', ()=>openDeckEditor('B'));

  // Deck editor modal
  $('closeDeck').addEventListener('click', closeDeckEditor);
  $('shuffleDeck').addEventListener('click', shuffleCurrentDeck);
  $('resetStart').addEventListener('click', resetToStart);

  // First-time: draw opening hands
  if(S.A.hand.length===0) drawUp('A');
  if(S.B.hand.length===0) drawUp('B');

  render();
}
function classApply(which, cls){
  const h = S[which];
  const ratio = h.hp / h.maxHP || 1;
  h.cls = cls;
  h.maxHP = mods[cls].maxHP;
  h.hp = clamp(Math.round(h.maxHP*ratio),0,h.maxHP);
  render();
}
init();
</script>
</body>
</html>
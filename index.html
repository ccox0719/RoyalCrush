function onBossDefeated(reason='defeated'){
  toast(`Royal ${reason} â€” rewards ready.`, 'good');
  // auto upgrades to both
  addUpgradeCardToHero(S.A, S.boss.rank, S.boss.suit);
  addUpgradeCardToHero(S.B, S.boss.rank, S.boss.suit);
  openRewards();
}

function openRewards(){
  buildChoices('A');
  buildChoices('B');
  document.getElementById('rewardsOverlay').classList.add('show');
}

function buildChoices(w){
  const holder = document.getElementById('choices'+w); holder.innerHTML='';
  const b = S.boss, h = S[w];
  const f = S.lastFinisher;

  const isFinisher = !!f && f.via==='hit' && f.who===w && f.matched===true && b.rank!=='X';

  if(isFinisher){
    const key = `${b.rank}${b.suit}`;
    const btn = document.createElement('button');
    btn.className = 'btn green';
    btn.textContent = `Add ${key} to deck (Legendary)`;
    btn.onclick = () => {
      h.discard.push({type:'face',rank:b.rank,s:b.suit});
      btn.disabled = true; btn.textContent='Added';
      toast(`Hero ${w}: +${key}`,'good');
    };
    holder.appendChild(btn);

    const info = document.createElement('div');
    info.className='sub'; info.style.marginTop='6px';
    info.textContent='Legendary added only to the finishing hero (matching suit).';
    holder.appendChild(info);
  } else {
    // Generics (rank-tiered) + auto-trash 1 lowest
    const keys = GENERIC_BY_RANK[b.rank] || [];
    keys.forEach(k=>{
      const g=GENERICS_ALL[k];
      const tag=document.createElement('button'); tag.className='tag';
      tag.textContent=g.label + ' + Trash 1';
      tag.onclick=()=>{ g.run(h); autoTrashLowest(h,1); tag.classList.add('hide'); toast(`Hero ${w}: Trashed lowest card (on generic)`, 'good'); render(); };
      holder.appendChild(tag);
    });
  }
}